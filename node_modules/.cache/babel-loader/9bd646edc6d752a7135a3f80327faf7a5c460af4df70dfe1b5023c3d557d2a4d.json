{"ast":null,"code":"/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.regexp.flags.js\");\nrequire(\"core-js/modules/es.array.unshift.js\");\n(function () {\n  var MOZ_TO_ME = {\n    Program: function (M) {\n      return new AST_Toplevel({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: normalize_directives(M.body.map(from_moz))\n      });\n    },\n    ArrowFunctionExpression: function (M) {\n      var argnames = [],\n        rest = null;\n      M.params.forEach(function (param) {\n        if (param.type == \"RestElement\") {\n          rest = from_moz(param.argument);\n        } else {\n          argnames.push(from_moz(param));\n        }\n      });\n      var fn = new (M.async ? AST_AsyncArrow : AST_Arrow)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        argnames: argnames,\n        rest: rest\n      });\n      var node = from_moz(M.body);\n      if (node instanceof AST_BlockStatement) {\n        fn.body = normalize_directives(node.body);\n        fn.value = null;\n      } else {\n        fn.body = [];\n        fn.value = node;\n      }\n      return fn;\n    },\n    FunctionDeclaration: function (M) {\n      var ctor;\n      if (M.async) {\n        ctor = M.generator ? AST_AsyncGeneratorDefun : AST_AsyncDefun;\n      } else {\n        ctor = M.generator ? AST_GeneratorDefun : AST_Defun;\n      }\n      var argnames = [],\n        rest = null;\n      M.params.forEach(function (param) {\n        if (param.type == \"RestElement\") {\n          rest = from_moz(param.argument);\n        } else {\n          argnames.push(from_moz(param));\n        }\n      });\n      return new ctor({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        argnames: argnames,\n        rest: rest,\n        body: normalize_directives(from_moz(M.body).body)\n      });\n    },\n    FunctionExpression: function (M) {\n      var ctor;\n      if (M.async) {\n        ctor = M.generator ? AST_AsyncGeneratorFunction : AST_AsyncFunction;\n      } else {\n        ctor = M.generator ? AST_GeneratorFunction : AST_Function;\n      }\n      var argnames = [],\n        rest = null;\n      M.params.forEach(function (param) {\n        if (param.type == \"RestElement\") {\n          rest = from_moz(param.argument);\n        } else {\n          argnames.push(from_moz(param));\n        }\n      });\n      return new ctor({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        argnames: argnames,\n        rest: rest,\n        body: normalize_directives(from_moz(M.body).body)\n      });\n    },\n    ClassDeclaration: function (M) {\n      return new AST_DefClass({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        extends: from_moz(M.superClass),\n        properties: M.body.body.map(from_moz)\n      });\n    },\n    ClassExpression: function (M) {\n      return new AST_ClassExpression({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        extends: from_moz(M.superClass),\n        properties: M.body.body.map(from_moz)\n      });\n    },\n    MethodDefinition: function (M) {\n      var key = M.key,\n        internal = false;\n      if (M.computed) {\n        key = from_moz(key);\n      } else if (key.type == \"PrivateIdentifier\") {\n        internal = true;\n        key = \"#\" + key.name;\n      } else {\n        key = read_name(key);\n      }\n      var ctor = AST_ClassMethod,\n        value = from_moz(M.value);\n      switch (M.kind) {\n        case \"get\":\n          ctor = AST_ClassGetter;\n          value = new AST_Accessor(value);\n          break;\n        case \"set\":\n          ctor = AST_ClassSetter;\n          value = new AST_Accessor(value);\n          break;\n      }\n      return new ctor({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key: key,\n        private: internal,\n        static: M.static,\n        value: value\n      });\n    },\n    PropertyDefinition: function (M) {\n      var key = M.key,\n        internal = false;\n      if (M.computed) {\n        key = from_moz(key);\n      } else if (key.type == \"PrivateIdentifier\") {\n        internal = true;\n        key = \"#\" + key.name;\n      } else {\n        key = read_name(key);\n      }\n      return new AST_ClassField({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key: key,\n        private: internal,\n        static: M.static,\n        value: from_moz(M.value)\n      });\n    },\n    StaticBlock: function (M) {\n      var start = my_start_token(M);\n      var end = my_end_token(M);\n      return new AST_ClassInit({\n        start: start,\n        end: end,\n        value: new AST_ClassInitBlock({\n          start: start,\n          end: end,\n          body: normalize_directives(M.body.map(from_moz))\n        })\n      });\n    },\n    ForOfStatement: function (M) {\n      return new (M.await ? AST_ForAwaitOf : AST_ForOf)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        init: from_moz(M.left),\n        object: from_moz(M.right),\n        body: from_moz(M.body)\n      });\n    },\n    TryStatement: function (M) {\n      var handlers = M.handlers || [M.handler];\n      if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n        throw new Error(\"Multiple catch clauses are not supported.\");\n      }\n      return new AST_Try({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: from_moz(M.block).body,\n        bcatch: from_moz(handlers[0]),\n        bfinally: M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null\n      });\n    },\n    Property: function (M) {\n      var key = M.computed ? from_moz(M.key) : read_name(M.key);\n      var args = {\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key: key,\n        value: from_moz(M.value)\n      };\n      if (M.kind == \"init\") return new (M.method ? AST_ObjectMethod : AST_ObjectKeyVal)(args);\n      args.value = new AST_Accessor(args.value);\n      if (M.kind == \"get\") return new AST_ObjectGetter(args);\n      if (M.kind == \"set\") return new AST_ObjectSetter(args);\n    },\n    ArrayExpression: function (M) {\n      return new AST_Array({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        elements: M.elements.map(function (elem) {\n          return elem === null ? new AST_Hole() : from_moz(elem);\n        })\n      });\n    },\n    ArrayPattern: function (M) {\n      var elements = [],\n        rest = null;\n      M.elements.forEach(function (el) {\n        if (el === null) {\n          elements.push(new AST_Hole());\n        } else if (el.type == \"RestElement\") {\n          rest = from_moz(el.argument);\n        } else {\n          elements.push(from_moz(el));\n        }\n      });\n      return new AST_DestructuredArray({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        elements: elements,\n        rest: rest\n      });\n    },\n    ObjectPattern: function (M) {\n      var props = [],\n        rest = null;\n      M.properties.forEach(function (prop) {\n        if (prop.type == \"RestElement\") {\n          rest = from_moz(prop.argument);\n        } else {\n          props.push(new AST_DestructuredKeyVal(from_moz(prop)));\n        }\n      });\n      return new AST_DestructuredObject({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        properties: props,\n        rest: rest\n      });\n    },\n    MemberExpression: function (M) {\n      return new (M.computed ? AST_Sub : AST_Dot)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        optional: M.optional,\n        expression: from_moz(M.object),\n        property: M.computed ? from_moz(M.property) : M.property.name\n      });\n    },\n    MetaProperty: function (M) {\n      var expr = from_moz(M.meta);\n      var prop = read_name(M.property);\n      if (expr.name == \"new\" && prop == \"target\") return new AST_NewTarget({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: \"new.target\"\n      });\n      return new AST_Dot({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: expr,\n        property: prop\n      });\n    },\n    SwitchCase: function (M) {\n      return new (M.test ? AST_Case : AST_Default)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.test),\n        body: M.consequent.map(from_moz)\n      });\n    },\n    ExportAllDeclaration: function (M) {\n      var start = my_start_token(M);\n      var end = my_end_token(M);\n      return new AST_ExportForeign({\n        start: start,\n        end: end,\n        aliases: [M.exported ? from_moz_alias(M.exported) : new AST_String({\n          start: start,\n          value: \"*\",\n          end: end\n        })],\n        keys: [new AST_String({\n          start: start,\n          value: \"*\",\n          end: end\n        })],\n        path: from_moz(M.source)\n      });\n    },\n    ExportDefaultDeclaration: function (M) {\n      var decl = from_moz(M.declaration);\n      if (!decl.name) switch (decl.CTOR) {\n        case AST_AsyncDefun:\n          decl = new AST_AsyncFunction(decl);\n          break;\n        case AST_AsyncGeneratorDefun:\n          decl = new AST_AsyncGeneratorFunction(decl);\n          break;\n        case AST_DefClass:\n          decl = new AST_ClassExpression(decl);\n          break;\n        case AST_Defun:\n          decl = new AST_Function(decl);\n          break;\n        case AST_GeneratorDefun:\n          decl = new AST_GeneratorFunction(decl);\n          break;\n      }\n      return new AST_ExportDefault({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: decl\n      });\n    },\n    ExportNamedDeclaration: function (M) {\n      if (M.declaration) return new AST_ExportDeclaration({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: from_moz(M.declaration)\n      });\n      if (M.source) {\n        var aliases = [],\n          keys = [];\n        M.specifiers.forEach(function (prop) {\n          aliases.push(from_moz_alias(prop.exported));\n          keys.push(from_moz_alias(prop.local));\n        });\n        return new AST_ExportForeign({\n          start: my_start_token(M),\n          end: my_end_token(M),\n          aliases: aliases,\n          keys: keys,\n          path: from_moz(M.source)\n        });\n      }\n      return new AST_ExportReferences({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        properties: M.specifiers.map(function (prop) {\n          var sym = new AST_SymbolExport(from_moz(prop.local));\n          sym.alias = from_moz_alias(prop.exported);\n          return sym;\n        })\n      });\n    },\n    ImportDeclaration: function (M) {\n      var start = my_start_token(M);\n      var end = my_end_token(M);\n      var all = null,\n        def = null,\n        props = null;\n      M.specifiers.forEach(function (prop) {\n        var sym = new AST_SymbolImport(from_moz(prop.local));\n        switch (prop.type) {\n          case \"ImportDefaultSpecifier\":\n            def = sym;\n            def.key = new AST_String({\n              start: start,\n              value: \"\",\n              end: end\n            });\n            break;\n          case \"ImportNamespaceSpecifier\":\n            all = sym;\n            all.key = new AST_String({\n              start: start,\n              value: \"*\",\n              end: end\n            });\n            break;\n          default:\n            sym.key = from_moz_alias(prop.imported);\n            if (!props) props = [];\n            props.push(sym);\n            break;\n        }\n      });\n      return new AST_Import({\n        start: start,\n        end: end,\n        all: all,\n        default: def,\n        properties: props,\n        path: from_moz(M.source)\n      });\n    },\n    ImportExpression: function (M) {\n      var start = my_start_token(M);\n      var arg = from_moz(M.source);\n      return new AST_Call({\n        start: start,\n        end: my_end_token(M),\n        expression: new AST_SymbolRef({\n          start: start,\n          end: arg.start,\n          name: \"import\"\n        }),\n        args: [arg]\n      });\n    },\n    VariableDeclaration: function (M) {\n      return new ({\n        const: AST_Const,\n        let: AST_Let\n      }[M.kind] || AST_Var)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        definitions: M.declarations.map(from_moz)\n      });\n    },\n    Literal: function (M) {\n      var args = {\n        start: my_start_token(M),\n        end: my_end_token(M)\n      };\n      if (M.bigint) {\n        args.value = M.bigint.toLowerCase() + \"n\";\n        return new AST_BigInt(args);\n      }\n      var val = M.value;\n      if (val === null) return new AST_Null(args);\n      var rx = M.regex;\n      if (rx && rx.pattern) {\n        // RegExpLiteral as per ESTree AST spec\n        args.value = new RegExp(rx.pattern, rx.flags);\n        args.value.raw_source = rx.pattern;\n        return new AST_RegExp(args);\n      } else if (rx) {\n        // support legacy RegExp\n        args.value = M.regex && M.raw ? M.raw : val;\n        return new AST_RegExp(args);\n      }\n      switch (typeof val) {\n        case \"string\":\n          args.value = val;\n          return new AST_String(args);\n        case \"number\":\n          if (isNaN(val)) return new AST_NaN(args);\n          var negate, node;\n          if (isFinite(val)) {\n            negate = 1 / val < 0;\n            args.value = negate ? -val : val;\n            node = new AST_Number(args);\n          } else {\n            negate = val < 0;\n            node = new AST_Infinity(args);\n          }\n          return negate ? new AST_UnaryPrefix({\n            start: args.start,\n            end: args.end,\n            operator: \"-\",\n            expression: node\n          }) : node;\n        case \"boolean\":\n          return new (val ? AST_True : AST_False)(args);\n      }\n    },\n    TemplateLiteral: function (M) {\n      return new AST_Template({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expressions: M.expressions.map(from_moz),\n        strings: M.quasis.map(function (el) {\n          return el.value.raw;\n        })\n      });\n    },\n    TaggedTemplateExpression: function (M) {\n      var tmpl = from_moz(M.quasi);\n      tmpl.start = my_start_token(M);\n      tmpl.end = my_end_token(M);\n      tmpl.tag = from_moz(M.tag);\n      return tmpl;\n    },\n    Identifier: function (M) {\n      var p,\n        level = FROM_MOZ_STACK.length - 1;\n      do {\n        p = FROM_MOZ_STACK[--level];\n      } while (p.type == \"ArrayPattern\" || p.type == \"AssignmentPattern\" && p.left === FROM_MOZ_STACK[level + 1] || p.type == \"ObjectPattern\" || p.type == \"Property\" && p.value === FROM_MOZ_STACK[level + 1] || p.type == \"VariableDeclarator\" && p.id === FROM_MOZ_STACK[level + 1]);\n      var ctor = AST_SymbolRef;\n      switch (p.type) {\n        case \"ArrowFunctionExpression\":\n          if (p.body !== FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolFunarg;\n          break;\n        case \"BreakStatement\":\n        case \"ContinueStatement\":\n          ctor = AST_LabelRef;\n          break;\n        case \"CatchClause\":\n          ctor = AST_SymbolCatch;\n          break;\n        case \"ClassDeclaration\":\n          if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolDefClass;\n          break;\n        case \"ClassExpression\":\n          if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolClass;\n          break;\n        case \"FunctionDeclaration\":\n          ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolDefun : AST_SymbolFunarg;\n          break;\n        case \"FunctionExpression\":\n          ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolLambda : AST_SymbolFunarg;\n          break;\n        case \"LabeledStatement\":\n          ctor = AST_Label;\n          break;\n        case \"VariableDeclaration\":\n          ctor = {\n            const: AST_SymbolConst,\n            let: AST_SymbolLet\n          }[p.kind] || AST_SymbolVar;\n          break;\n      }\n      return new ctor({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: M.name\n      });\n    },\n    Super: function (M) {\n      return new AST_Super({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: \"super\"\n      });\n    },\n    ThisExpression: function (M) {\n      return new AST_This({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: \"this\"\n      });\n    },\n    ParenthesizedExpression: function (M) {\n      var node = from_moz(M.expression);\n      if (!node.start.parens) node.start.parens = [];\n      node.start.parens.push(my_start_token(M));\n      if (!node.end.parens) node.end.parens = [];\n      node.end.parens.push(my_end_token(M));\n      return node;\n    },\n    ChainExpression: function (M) {\n      var node = from_moz(M.expression);\n      node.terminal = true;\n      return node;\n    }\n  };\n  MOZ_TO_ME.UpdateExpression = MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n    var prefix = \"prefix\" in M ? M.prefix : M.type == \"UnaryExpression\" ? true : false;\n    return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n      start: my_start_token(M),\n      end: my_end_token(M),\n      operator: M.operator,\n      expression: from_moz(M.argument)\n    });\n  };\n  map(\"EmptyStatement\", AST_EmptyStatement);\n  map(\"ExpressionStatement\", AST_SimpleStatement, \"expression>body\");\n  map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n  map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n  map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n  map(\"BreakStatement\", AST_Break, \"label>label\");\n  map(\"ContinueStatement\", AST_Continue, \"label>label\");\n  map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n  map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n  map(\"ReturnStatement\", AST_Return, \"argument>value\");\n  map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n  map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n  map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n  map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n  map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n  map(\"DebuggerStatement\", AST_Debugger);\n  map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n  map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n  map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n  map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n  map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n  map(\"AssignmentPattern\", AST_DefaultValue, \"left>name, right>value\");\n  map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n  map(\"NewExpression\", AST_New, \"callee>expression, arguments@args, pure=pure\");\n  map(\"CallExpression\", AST_Call, \"callee>expression, arguments@args, optional=optional, pure=pure\");\n  map(\"SequenceExpression\", AST_Sequence, \"expressions@expressions\");\n  map(\"SpreadElement\", AST_Spread, \"argument>expression\");\n  map(\"ObjectExpression\", AST_Object, \"properties@properties\");\n  map(\"AwaitExpression\", AST_Await, \"argument>expression\");\n  map(\"YieldExpression\", AST_Yield, \"argument>expression, delegate=nested\");\n  def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n    return to_moz_scope(\"Program\", M);\n  });\n  def_to_moz(AST_LambdaDefinition, function To_Moz_FunctionDeclaration(M) {\n    var params = M.argnames.map(to_moz);\n    if (M.rest) params.push({\n      type: \"RestElement\",\n      argument: to_moz(M.rest)\n    });\n    return {\n      type: \"FunctionDeclaration\",\n      id: to_moz(M.name),\n      async: is_async(M),\n      generator: is_generator(M),\n      params: params,\n      body: to_moz_scope(\"BlockStatement\", M)\n    };\n  });\n  def_to_moz(AST_Lambda, function To_Moz_FunctionExpression(M) {\n    var params = M.argnames.map(to_moz);\n    if (M.rest) params.push({\n      type: \"RestElement\",\n      argument: to_moz(M.rest)\n    });\n    if (is_arrow(M)) return {\n      type: \"ArrowFunctionExpression\",\n      async: is_async(M),\n      params: params,\n      body: M.value ? to_moz(M.value) : to_moz_scope(\"BlockStatement\", M)\n    };\n    return {\n      type: \"FunctionExpression\",\n      id: to_moz(M.name),\n      async: is_async(M),\n      generator: is_generator(M),\n      params: params,\n      body: to_moz_scope(\"BlockStatement\", M)\n    };\n  });\n  def_to_moz(AST_DefClass, function To_Moz_ClassDeclaration(M) {\n    return {\n      type: \"ClassDeclaration\",\n      id: to_moz(M.name),\n      superClass: to_moz(M.extends),\n      body: {\n        type: \"ClassBody\",\n        body: M.properties.map(to_moz)\n      }\n    };\n  });\n  def_to_moz(AST_ClassExpression, function To_Moz_ClassExpression(M) {\n    return {\n      type: \"ClassExpression\",\n      id: to_moz(M.name),\n      superClass: to_moz(M.extends),\n      body: {\n        type: \"ClassBody\",\n        body: M.properties.map(to_moz)\n      }\n    };\n  });\n  function To_Moz_MethodDefinition(kind) {\n    return function (M) {\n      var computed = M.key instanceof AST_Node;\n      var key = computed ? to_moz(M.key) : M.private ? {\n        type: \"PrivateIdentifier\",\n        name: M.key.slice(1)\n      } : {\n        type: \"Literal\",\n        value: M.key\n      };\n      return {\n        type: \"MethodDefinition\",\n        kind: kind,\n        computed: computed,\n        key: key,\n        static: M.static,\n        value: to_moz(M.value)\n      };\n    };\n  }\n  def_to_moz(AST_ClassGetter, To_Moz_MethodDefinition(\"get\"));\n  def_to_moz(AST_ClassSetter, To_Moz_MethodDefinition(\"set\"));\n  def_to_moz(AST_ClassMethod, To_Moz_MethodDefinition(\"method\"));\n  def_to_moz(AST_ClassField, function To_Moz_PropertyDefinition(M) {\n    var computed = M.key instanceof AST_Node;\n    var key = computed ? to_moz(M.key) : M.private ? {\n      type: \"PrivateIdentifier\",\n      name: M.key.slice(1)\n    } : {\n      type: \"Literal\",\n      value: M.key\n    };\n    return {\n      type: \"PropertyDefinition\",\n      computed: computed,\n      key: key,\n      static: M.static,\n      value: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_ClassInit, function To_Moz_StaticBlock(M) {\n    return to_moz_scope(\"StaticBlock\", M.value);\n  });\n  function To_Moz_ForOfStatement(is_await) {\n    return function (M) {\n      return {\n        type: \"ForOfStatement\",\n        await: is_await,\n        left: to_moz(M.init),\n        right: to_moz(M.object),\n        body: to_moz(M.body)\n      };\n    };\n  }\n  def_to_moz(AST_ForAwaitOf, To_Moz_ForOfStatement(true));\n  def_to_moz(AST_ForOf, To_Moz_ForOfStatement(false));\n  def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n    return {\n      type: \"ExpressionStatement\",\n      expression: set_moz_loc(M, {\n        type: \"Literal\",\n        value: M.value\n      })\n    };\n  });\n  def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n    return {\n      type: \"SwitchCase\",\n      test: to_moz(M.expression),\n      consequent: M.body.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n    return {\n      type: \"TryStatement\",\n      block: to_moz_block(M),\n      handler: to_moz(M.bcatch),\n      guardedHandlers: [],\n      finalizer: to_moz(M.bfinally)\n    };\n  });\n  def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n    return {\n      type: \"CatchClause\",\n      param: to_moz(M.argname),\n      guard: null,\n      body: to_moz_block(M)\n    };\n  });\n  def_to_moz(AST_ExportDeclaration, function To_Moz_ExportNamedDeclaration_declaration(M) {\n    return {\n      type: \"ExportNamedDeclaration\",\n      declaration: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_ExportDefault, function To_Moz_ExportDefaultDeclaration(M) {\n    return {\n      type: \"ExportDefaultDeclaration\",\n      declaration: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_ExportForeign, function To_Moz_ExportAllDeclaration_ExportNamedDeclaration(M) {\n    if (M.keys[0].value == \"*\") return {\n      type: \"ExportAllDeclaration\",\n      exported: M.aliases[0].value == \"*\" ? null : to_moz_alias(M.aliases[0]),\n      source: to_moz(M.path)\n    };\n    var specifiers = [];\n    for (var i = 0; i < M.aliases.length; i++) {\n      specifiers.push(set_moz_loc({\n        start: M.keys[i].start,\n        end: M.aliases[i].end\n      }, {\n        type: \"ExportSpecifier\",\n        local: to_moz_alias(M.keys[i]),\n        exported: to_moz_alias(M.aliases[i])\n      }));\n    }\n    return {\n      type: \"ExportNamedDeclaration\",\n      specifiers: specifiers,\n      source: to_moz(M.path)\n    };\n  });\n  def_to_moz(AST_ExportReferences, function To_Moz_ExportNamedDeclaration_specifiers(M) {\n    return {\n      type: \"ExportNamedDeclaration\",\n      specifiers: M.properties.map(function (prop) {\n        return set_moz_loc({\n          start: prop.start,\n          end: prop.alias.end\n        }, {\n          type: \"ExportSpecifier\",\n          local: to_moz(prop),\n          exported: to_moz_alias(prop.alias)\n        });\n      })\n    };\n  });\n  def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n    var specifiers = M.properties ? M.properties.map(function (prop) {\n      return set_moz_loc({\n        start: prop.key.start,\n        end: prop.end\n      }, {\n        type: \"ImportSpecifier\",\n        local: to_moz(prop),\n        imported: to_moz_alias(prop.key)\n      });\n    }) : [];\n    if (M.all) specifiers.unshift(set_moz_loc(M.all, {\n      type: \"ImportNamespaceSpecifier\",\n      local: to_moz(M.all)\n    }));\n    if (M.default) specifiers.unshift(set_moz_loc(M.default, {\n      type: \"ImportDefaultSpecifier\",\n      local: to_moz(M.default)\n    }));\n    return {\n      type: \"ImportDeclaration\",\n      specifiers: specifiers,\n      source: to_moz(M.path)\n    };\n  });\n  def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n    return {\n      type: \"VariableDeclaration\",\n      kind: M.TYPE.toLowerCase(),\n      declarations: M.definitions.map(to_moz)\n    };\n  });\n  def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n    var computed = M instanceof AST_Sub;\n    var expr = {\n      type: \"MemberExpression\",\n      object: to_moz(M.expression),\n      computed: computed,\n      optional: M.optional,\n      property: computed ? to_moz(M.property) : {\n        type: \"Identifier\",\n        name: M.property\n      }\n    };\n    return M.terminal ? {\n      type: \"ChainExpression\",\n      expression: expr\n    } : expr;\n  });\n  def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n    return {\n      type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n      operator: M.operator,\n      prefix: M instanceof AST_UnaryPrefix,\n      argument: to_moz(M.expression)\n    };\n  });\n  def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n    return {\n      type: M.operator == \"&&\" || M.operator == \"||\" ? \"LogicalExpression\" : \"BinaryExpression\",\n      left: to_moz(M.left),\n      operator: M.operator,\n      right: to_moz(M.right)\n    };\n  });\n  def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n    return {\n      type: \"ArrayExpression\",\n      elements: M.elements.map(to_moz)\n    };\n  });\n  def_to_moz(AST_DestructuredArray, function To_Moz_ArrayPattern(M) {\n    var elements = M.elements.map(to_moz);\n    if (M.rest) elements.push({\n      type: \"RestElement\",\n      argument: to_moz(M.rest)\n    });\n    return {\n      type: \"ArrayPattern\",\n      elements: elements\n    };\n  });\n  def_to_moz(AST_DestructuredKeyVal, function To_Moz_Property(M) {\n    var computed = M.key instanceof AST_Node;\n    var key = computed ? to_moz(M.key) : {\n      type: \"Literal\",\n      value: M.key\n    };\n    return {\n      type: \"Property\",\n      kind: \"init\",\n      computed: computed,\n      key: key,\n      value: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_DestructuredObject, function To_Moz_ObjectPattern(M) {\n    var props = M.properties.map(to_moz);\n    if (M.rest) props.push({\n      type: \"RestElement\",\n      argument: to_moz(M.rest)\n    });\n    return {\n      type: \"ObjectPattern\",\n      properties: props\n    };\n  });\n  def_to_moz(AST_ObjectProperty, function To_Moz_Property(M) {\n    var computed = M.key instanceof AST_Node;\n    var key = computed ? to_moz(M.key) : {\n      type: \"Literal\",\n      value: M.key\n    };\n    var kind;\n    if (M instanceof AST_ObjectKeyVal) {\n      kind = \"init\";\n    } else if (M instanceof AST_ObjectGetter) {\n      kind = \"get\";\n    } else if (M instanceof AST_ObjectSetter) {\n      kind = \"set\";\n    }\n    return {\n      type: \"Property\",\n      kind: kind,\n      computed: computed,\n      method: M instanceof AST_ObjectMethod,\n      key: key,\n      value: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_Symbol, function To_Moz_Identifier(M) {\n    var def = M.definition();\n    return {\n      type: \"Identifier\",\n      name: def && def.mangled_name || M.name\n    };\n  });\n  def_to_moz(AST_Super, function To_Moz_Super() {\n    return {\n      type: \"Super\"\n    };\n  });\n  def_to_moz(AST_This, function To_Moz_ThisExpression() {\n    return {\n      type: \"ThisExpression\"\n    };\n  });\n  def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n    return {\n      type: \"MetaProperty\",\n      meta: {\n        type: \"Identifier\",\n        name: \"new\"\n      },\n      property: {\n        type: \"Identifier\",\n        name: \"target\"\n      }\n    };\n  });\n  def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n    var flags = M.value.toString().match(/\\/([gimuy]*)$/)[1];\n    var value = \"/\" + M.value.raw_source + \"/\" + flags;\n    return {\n      type: \"Literal\",\n      value: value,\n      raw: value,\n      regex: {\n        pattern: M.value.raw_source,\n        flags: flags\n      }\n    };\n  });\n  def_to_moz(AST_BigInt, function To_Moz_BigInt(M) {\n    var value = M.value;\n    return {\n      type: \"Literal\",\n      bigint: value.slice(0, -1),\n      raw: value\n    };\n  });\n  function To_Moz_Literal(M) {\n    var value = M.value;\n    if (typeof value === \"number\" && (value < 0 || value === 0 && 1 / value < 0)) {\n      return {\n        type: \"UnaryExpression\",\n        operator: \"-\",\n        prefix: true,\n        argument: {\n          type: \"Literal\",\n          value: -value,\n          raw: M.start.raw\n        }\n      };\n    }\n    return {\n      type: \"Literal\",\n      value: value,\n      raw: M.start.raw\n    };\n  }\n  def_to_moz(AST_Boolean, To_Moz_Literal);\n  def_to_moz(AST_Constant, To_Moz_Literal);\n  def_to_moz(AST_Null, To_Moz_Literal);\n  def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n    return {\n      type: \"Identifier\",\n      name: String(M.value)\n    };\n  });\n  def_to_moz(AST_Template, function To_Moz_TemplateLiteral_TaggedTemplateExpression(M) {\n    var last = M.strings.length - 1;\n    var tmpl = {\n      type: \"TemplateLiteral\",\n      expressions: M.expressions.map(to_moz),\n      quasis: M.strings.map(function (str, index) {\n        return {\n          type: \"TemplateElement\",\n          tail: index == last,\n          value: {\n            raw: str\n          }\n        };\n      })\n    };\n    if (!M.tag) return tmpl;\n    return {\n      type: \"TaggedTemplateExpression\",\n      tag: to_moz(M.tag),\n      quasi: tmpl\n    };\n  });\n  AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n  AST_Hole.DEFMETHOD(\"to_mozilla_ast\", return_null);\n  AST_Node.DEFMETHOD(\"to_mozilla_ast\", function () {\n    throw new Error(\"Cannot convert AST_\" + this.TYPE);\n  });\n\n  /* -----[ tools ]----- */\n\n  function normalize_directives(body) {\n    for (var i = 0; i < body.length; i++) {\n      var stat = body[i];\n      if (!(stat instanceof AST_SimpleStatement)) break;\n      var node = stat.body;\n      if (!(node instanceof AST_String)) break;\n      if (stat.start.pos !== node.start.pos) break;\n      body[i] = new AST_Directive(node);\n    }\n    return body;\n  }\n  function raw_token(moznode) {\n    if (moznode.type == \"Literal\") {\n      return moznode.raw != null ? moznode.raw : moznode.value + \"\";\n    }\n  }\n  function my_start_token(moznode) {\n    var loc = moznode.loc,\n      start = loc && loc.start;\n    var range = moznode.range;\n    return new AST_Token({\n      file: loc && loc.source,\n      line: start && start.line,\n      col: start && start.column,\n      pos: range ? range[0] : moznode.start,\n      endline: start && start.line,\n      endcol: start && start.column,\n      endpos: range ? range[0] : moznode.start,\n      raw: raw_token(moznode)\n    });\n  }\n  function my_end_token(moznode) {\n    var loc = moznode.loc,\n      end = loc && loc.end;\n    var range = moznode.range;\n    return new AST_Token({\n      file: loc && loc.source,\n      line: end && end.line,\n      col: end && end.column,\n      pos: range ? range[1] : moznode.end,\n      endline: end && end.line,\n      endcol: end && end.column,\n      endpos: range ? range[1] : moznode.end,\n      raw: raw_token(moznode)\n    });\n  }\n  function read_name(M) {\n    return \"\" + M[M.type == \"Identifier\" ? \"name\" : \"value\"];\n  }\n  function map(moztype, mytype, propmap) {\n    var moz_to_me = [\"start: my_start_token(M)\", \"end: my_end_token(M)\"];\n    var me_to_moz = [\"type: \" + JSON.stringify(moztype)];\n    if (propmap) propmap.split(/\\s*,\\s*/).forEach(function (prop) {\n      var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);\n      if (!m) throw new Error(\"Can't understand property map: \" + prop);\n      var moz = m[1],\n        how = m[2],\n        my = m[3];\n      switch (how) {\n        case \"@\":\n          moz_to_me.push(my + \": M.\" + moz + \".map(from_moz)\");\n          me_to_moz.push(moz + \": M.\" + my + \".map(to_moz)\");\n          break;\n        case \">\":\n          moz_to_me.push(my + \": from_moz(M.\" + moz + \")\");\n          me_to_moz.push(moz + \": to_moz(M.\" + my + \")\");\n          break;\n        case \"=\":\n          moz_to_me.push(my + \": M.\" + moz);\n          me_to_moz.push(moz + \": M.\" + my);\n          break;\n        case \"%\":\n          moz_to_me.push(my + \": from_moz(M.\" + moz + \").body\");\n          me_to_moz.push(moz + \": to_moz_block(M)\");\n          break;\n        default:\n          throw new Error(\"Can't understand operator in propmap: \" + prop);\n      }\n    });\n    MOZ_TO_ME[moztype] = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", [\"return function From_Moz_\" + moztype + \"(M) {\", \"    return new U2.AST_\" + mytype.TYPE + \"({\", moz_to_me.join(\",\\n\"), \"    });\", \"};\"].join(\"\\n\"))(exports, my_start_token, my_end_token, from_moz);\n    def_to_moz(mytype, new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", [\"return function To_Moz_\" + moztype + \"(M) {\", \"    return {\", me_to_moz.join(\",\\n\"), \"    };\", \"};\"].join(\"\\n\"))(to_moz, to_moz_block, to_moz_scope));\n  }\n  var FROM_MOZ_STACK = null;\n  function from_moz(moz) {\n    FROM_MOZ_STACK.push(moz);\n    var node = null;\n    if (moz) {\n      if (!HOP(MOZ_TO_ME, moz.type)) throw new Error(\"Unsupported type: \" + moz.type);\n      node = MOZ_TO_ME[moz.type](moz);\n    }\n    FROM_MOZ_STACK.pop();\n    return node;\n  }\n  function from_moz_alias(moz) {\n    return new AST_String({\n      start: my_start_token(moz),\n      value: read_name(moz),\n      end: my_end_token(moz)\n    });\n  }\n  AST_Node.from_mozilla_ast = function (node) {\n    var save_stack = FROM_MOZ_STACK;\n    FROM_MOZ_STACK = [];\n    var ast = from_moz(node);\n    FROM_MOZ_STACK = save_stack;\n    ast.walk(new TreeWalker(function (node) {\n      if (node instanceof AST_LabelRef) {\n        for (var level = 0, parent; parent = this.parent(level); level++) {\n          if (parent instanceof AST_Scope) break;\n          if (parent instanceof AST_LabeledStatement && parent.label.name == node.name) {\n            node.thedef = parent.label;\n            break;\n          }\n        }\n        if (!node.thedef) {\n          var s = node.start;\n          js_error(\"Undefined label \" + node.name, s.file, s.line, s.col, s.pos);\n        }\n      }\n    }));\n    return ast;\n  };\n  function set_moz_loc(mynode, moznode) {\n    var start = mynode.start;\n    var end = mynode.end;\n    if (start.pos != null && end.endpos != null) {\n      moznode.range = [start.pos, end.endpos];\n    }\n    if (start.line) {\n      moznode.loc = {\n        start: {\n          line: start.line,\n          column: start.col\n        },\n        end: end.endline ? {\n          line: end.endline,\n          column: end.endcol\n        } : null\n      };\n      if (start.file) {\n        moznode.loc.source = start.file;\n      }\n    }\n    return moznode;\n  }\n  function def_to_moz(mytype, handler) {\n    mytype.DEFMETHOD(\"to_mozilla_ast\", function () {\n      return set_moz_loc(this, handler(this));\n    });\n  }\n  function to_moz(node) {\n    return node != null ? node.to_mozilla_ast() : null;\n  }\n  function to_moz_alias(alias) {\n    return is_identifier_string(alias.value) ? set_moz_loc(alias, {\n      type: \"Identifier\",\n      name: alias.value\n    }) : to_moz(alias);\n  }\n  function to_moz_block(node) {\n    return {\n      type: \"BlockStatement\",\n      body: node.body.map(to_moz)\n    };\n  }\n  function to_moz_scope(type, node) {\n    var body = node.body.map(to_moz);\n    if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n      body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n    }\n    return {\n      type: type,\n      body: body\n    };\n  }\n})();","map":{"version":3,"names":["require","MOZ_TO_ME","Program","M","AST_Toplevel","start","my_start_token","end","my_end_token","body","normalize_directives","map","from_moz","ArrowFunctionExpression","argnames","rest","params","forEach","param","type","argument","push","fn","async","AST_AsyncArrow","AST_Arrow","node","AST_BlockStatement","value","FunctionDeclaration","ctor","generator","AST_AsyncGeneratorDefun","AST_AsyncDefun","AST_GeneratorDefun","AST_Defun","name","id","FunctionExpression","AST_AsyncGeneratorFunction","AST_AsyncFunction","AST_GeneratorFunction","AST_Function","ClassDeclaration","AST_DefClass","extends","superClass","properties","ClassExpression","AST_ClassExpression","MethodDefinition","key","internal","computed","read_name","AST_ClassMethod","kind","AST_ClassGetter","AST_Accessor","AST_ClassSetter","private","static","PropertyDefinition","AST_ClassField","StaticBlock","AST_ClassInit","AST_ClassInitBlock","ForOfStatement","await","AST_ForAwaitOf","AST_ForOf","init","left","object","right","TryStatement","handlers","handler","length","guardedHandlers","Error","AST_Try","block","bcatch","bfinally","finalizer","AST_Finally","Property","args","method","AST_ObjectMethod","AST_ObjectKeyVal","AST_ObjectGetter","AST_ObjectSetter","ArrayExpression","AST_Array","elements","elem","AST_Hole","ArrayPattern","el","AST_DestructuredArray","ObjectPattern","props","prop","AST_DestructuredKeyVal","AST_DestructuredObject","MemberExpression","AST_Sub","AST_Dot","optional","expression","property","MetaProperty","expr","meta","AST_NewTarget","SwitchCase","test","AST_Case","AST_Default","consequent","ExportAllDeclaration","AST_ExportForeign","aliases","exported","from_moz_alias","AST_String","keys","path","source","ExportDefaultDeclaration","decl","declaration","CTOR","AST_ExportDefault","ExportNamedDeclaration","AST_ExportDeclaration","specifiers","local","AST_ExportReferences","sym","AST_SymbolExport","alias","ImportDeclaration","all","def","AST_SymbolImport","imported","AST_Import","default","ImportExpression","arg","AST_Call","AST_SymbolRef","VariableDeclaration","const","AST_Const","let","AST_Let","AST_Var","definitions","declarations","Literal","bigint","toLowerCase","AST_BigInt","val","AST_Null","rx","regex","pattern","RegExp","flags","raw_source","AST_RegExp","raw","isNaN","AST_NaN","negate","isFinite","AST_Number","AST_Infinity","AST_UnaryPrefix","operator","AST_True","AST_False","TemplateLiteral","AST_Template","expressions","strings","quasis","TaggedTemplateExpression","tmpl","quasi","tag","Identifier","p","level","FROM_MOZ_STACK","AST_SymbolFunarg","AST_LabelRef","AST_SymbolCatch","AST_SymbolDefClass","AST_SymbolClass","AST_SymbolDefun","AST_SymbolLambda","AST_Label","AST_SymbolConst","AST_SymbolLet","AST_SymbolVar","Super","AST_Super","ThisExpression","AST_This","ParenthesizedExpression","parens","ChainExpression","terminal","UpdateExpression","UnaryExpression","To_Moz_Unary","prefix","AST_UnaryPostfix","AST_EmptyStatement","AST_SimpleStatement","AST_If","AST_LabeledStatement","AST_Break","AST_Continue","AST_With","AST_Switch","AST_Return","AST_Throw","AST_While","AST_Do","AST_For","AST_ForIn","AST_Debugger","AST_VarDef","AST_Catch","AST_Binary","AST_Assign","AST_DefaultValue","AST_Conditional","AST_New","AST_Sequence","AST_Spread","AST_Object","AST_Await","AST_Yield","def_to_moz","To_Moz_Program","to_moz_scope","AST_LambdaDefinition","To_Moz_FunctionDeclaration","to_moz","is_async","is_generator","AST_Lambda","To_Moz_FunctionExpression","is_arrow","To_Moz_ClassDeclaration","To_Moz_ClassExpression","To_Moz_MethodDefinition","AST_Node","slice","To_Moz_PropertyDefinition","To_Moz_StaticBlock","To_Moz_ForOfStatement","is_await","AST_Directive","To_Moz_Directive","set_moz_loc","AST_SwitchBranch","To_Moz_SwitchCase","To_Moz_TryStatement","to_moz_block","To_Moz_CatchClause","argname","guard","To_Moz_ExportNamedDeclaration_declaration","To_Moz_ExportDefaultDeclaration","To_Moz_ExportAllDeclaration_ExportNamedDeclaration","to_moz_alias","i","To_Moz_ExportNamedDeclaration_specifiers","To_Moz_ImportDeclaration","unshift","AST_Definitions","To_Moz_VariableDeclaration","TYPE","AST_PropAccess","To_Moz_MemberExpression","AST_Unary","To_Moz_BinaryExpression","To_Moz_ArrayExpression","To_Moz_ArrayPattern","To_Moz_Property","To_Moz_ObjectPattern","AST_ObjectProperty","AST_Symbol","To_Moz_Identifier","definition","mangled_name","To_Moz_Super","To_Moz_ThisExpression","To_Moz_MetaProperty","To_Moz_RegExpLiteral","toString","match","To_Moz_BigInt","To_Moz_Literal","AST_Boolean","AST_Constant","AST_Atom","To_Moz_Atom","String","To_Moz_TemplateLiteral_TaggedTemplateExpression","last","str","index","tail","AST_Block","DEFMETHOD","prototype","to_mozilla_ast","return_null","stat","pos","raw_token","moznode","loc","range","AST_Token","file","line","col","column","endline","endcol","endpos","moztype","mytype","propmap","moz_to_me","me_to_moz","JSON","stringify","split","m","exec","moz","how","my","Function","join","exports","HOP","pop","from_mozilla_ast","save_stack","ast","walk","TreeWalker","parent","AST_Scope","label","thedef","s","js_error","mynode","is_identifier_string"],"sources":["/home/teresol/node_modules/uglify-js/lib/mozilla-ast.js"],"sourcesContent":["/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\n(function() {\n    var MOZ_TO_ME = {\n        Program: function(M) {\n            return new AST_Toplevel({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: normalize_directives(M.body.map(from_moz)),\n            });\n        },\n        ArrowFunctionExpression: function(M) {\n            var argnames = [], rest = null;\n            M.params.forEach(function(param) {\n                if (param.type == \"RestElement\") {\n                    rest = from_moz(param.argument);\n                } else {\n                    argnames.push(from_moz(param));\n                }\n            });\n            var fn = new (M.async ? AST_AsyncArrow : AST_Arrow)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                argnames: argnames,\n                rest: rest,\n            });\n            var node = from_moz(M.body);\n            if (node instanceof AST_BlockStatement) {\n                fn.body = normalize_directives(node.body);\n                fn.value = null;\n            } else {\n                fn.body = [];\n                fn.value = node;\n            }\n            return fn;\n        },\n        FunctionDeclaration: function(M) {\n            var ctor;\n            if (M.async) {\n                ctor = M.generator ? AST_AsyncGeneratorDefun : AST_AsyncDefun;\n            } else {\n                ctor = M.generator ? AST_GeneratorDefun : AST_Defun;\n            }\n            var argnames = [], rest = null;\n            M.params.forEach(function(param) {\n                if (param.type == \"RestElement\") {\n                    rest = from_moz(param.argument);\n                } else {\n                    argnames.push(from_moz(param));\n                }\n            });\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: argnames,\n                rest: rest,\n                body: normalize_directives(from_moz(M.body).body),\n            });\n        },\n        FunctionExpression: function(M) {\n            var ctor;\n            if (M.async) {\n                ctor = M.generator ? AST_AsyncGeneratorFunction : AST_AsyncFunction;\n            } else {\n                ctor = M.generator ? AST_GeneratorFunction : AST_Function;\n            }\n            var argnames = [], rest = null;\n            M.params.forEach(function(param) {\n                if (param.type == \"RestElement\") {\n                    rest = from_moz(param.argument);\n                } else {\n                    argnames.push(from_moz(param));\n                }\n            });\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: argnames,\n                rest: rest,\n                body: normalize_directives(from_moz(M.body).body),\n            });\n        },\n        ClassDeclaration: function(M) {\n            return new AST_DefClass({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                extends: from_moz(M.superClass),\n                properties: M.body.body.map(from_moz),\n            });\n        },\n        ClassExpression: function(M) {\n            return new AST_ClassExpression({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                extends: from_moz(M.superClass),\n                properties: M.body.body.map(from_moz),\n            });\n        },\n        MethodDefinition: function(M) {\n            var key = M.key, internal = false;\n            if (M.computed) {\n                key = from_moz(key);\n            } else if (key.type == \"PrivateIdentifier\") {\n                internal = true;\n                key = \"#\" + key.name;\n            } else {\n                key = read_name(key);\n            }\n            var ctor = AST_ClassMethod, value = from_moz(M.value);\n            switch (M.kind) {\n              case \"get\":\n                ctor = AST_ClassGetter;\n                value = new AST_Accessor(value);\n                break;\n              case \"set\":\n                ctor = AST_ClassSetter;\n                value = new AST_Accessor(value);\n                break;\n            }\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                key: key,\n                private: internal,\n                static: M.static,\n                value: value,\n            });\n        },\n        PropertyDefinition: function(M) {\n            var key = M.key, internal = false;\n            if (M.computed) {\n                key = from_moz(key);\n            } else if (key.type == \"PrivateIdentifier\") {\n                internal = true;\n                key = \"#\" + key.name;\n            } else {\n                key = read_name(key);\n            }\n            return new AST_ClassField({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                key: key,\n                private: internal,\n                static: M.static,\n                value: from_moz(M.value),\n            });\n        },\n        StaticBlock: function(M) {\n            var start = my_start_token(M);\n            var end = my_end_token(M);\n            return new AST_ClassInit({\n                start: start,\n                end: end,\n                value: new AST_ClassInitBlock({\n                    start: start,\n                    end: end,\n                    body: normalize_directives(M.body.map(from_moz)),\n                }),\n            });\n        },\n        ForOfStatement: function(M) {\n            return new (M.await ? AST_ForAwaitOf : AST_ForOf)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                init: from_moz(M.left),\n                object: from_moz(M.right),\n                body: from_moz(M.body),\n            });\n        },\n        TryStatement: function(M) {\n            var handlers = M.handlers || [M.handler];\n            if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n                throw new Error(\"Multiple catch clauses are not supported.\");\n            }\n            return new AST_Try({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                body     : from_moz(M.block).body,\n                bcatch   : from_moz(handlers[0]),\n                bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null,\n            });\n        },\n        Property: function(M) {\n            var key = M.computed ? from_moz(M.key) : read_name(M.key);\n            var args = {\n                start: my_start_token(M),\n                end: my_end_token(M),\n                key: key,\n                value: from_moz(M.value),\n            };\n            if (M.kind == \"init\") return new (M.method ? AST_ObjectMethod : AST_ObjectKeyVal)(args);\n            args.value = new AST_Accessor(args.value);\n            if (M.kind == \"get\") return new AST_ObjectGetter(args);\n            if (M.kind == \"set\") return new AST_ObjectSetter(args);\n        },\n        ArrayExpression: function(M) {\n            return new AST_Array({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                elements: M.elements.map(function(elem) {\n                    return elem === null ? new AST_Hole() : from_moz(elem);\n                }),\n            });\n        },\n        ArrayPattern: function(M) {\n            var elements = [], rest = null;\n            M.elements.forEach(function(el) {\n                if (el === null) {\n                    elements.push(new AST_Hole());\n                } else if (el.type == \"RestElement\") {\n                    rest = from_moz(el.argument);\n                } else {\n                    elements.push(from_moz(el));\n                }\n            });\n            return new AST_DestructuredArray({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                elements: elements,\n                rest: rest,\n            });\n        },\n        ObjectPattern: function(M) {\n            var props = [], rest = null;\n            M.properties.forEach(function(prop) {\n                if (prop.type == \"RestElement\") {\n                    rest = from_moz(prop.argument);\n                } else {\n                    props.push(new AST_DestructuredKeyVal(from_moz(prop)));\n                }\n            });\n            return new AST_DestructuredObject({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                properties: props,\n                rest: rest,\n            });\n        },\n        MemberExpression: function(M) {\n            return new (M.computed ? AST_Sub : AST_Dot)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                optional: M.optional,\n                expression: from_moz(M.object),\n                property: M.computed ? from_moz(M.property) : M.property.name,\n            });\n        },\n        MetaProperty: function(M) {\n            var expr = from_moz(M.meta);\n            var prop = read_name(M.property);\n            if (expr.name == \"new\" && prop == \"target\") return new AST_NewTarget({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: \"new.target\",\n            });\n            return new AST_Dot({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: expr,\n                property: prop,\n            });\n        },\n        SwitchCase: function(M) {\n            return new (M.test ? AST_Case : AST_Default)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expression : from_moz(M.test),\n                body       : M.consequent.map(from_moz),\n            });\n        },\n        ExportAllDeclaration: function(M) {\n            var start = my_start_token(M);\n            var end = my_end_token(M);\n            return new AST_ExportForeign({\n                start: start,\n                end: end,\n                aliases: [ M.exported ? from_moz_alias(M.exported) : new AST_String({\n                    start: start,\n                    value: \"*\",\n                    end: end,\n                }) ],\n                keys: [ new AST_String({\n                    start: start,\n                    value: \"*\",\n                    end: end,\n                }) ],\n                path: from_moz(M.source),\n            });\n        },\n        ExportDefaultDeclaration: function(M) {\n            var decl = from_moz(M.declaration);\n            if (!decl.name) switch (decl.CTOR) {\n              case AST_AsyncDefun:\n                decl = new AST_AsyncFunction(decl);\n                break;\n              case AST_AsyncGeneratorDefun:\n                decl = new AST_AsyncGeneratorFunction(decl);\n                break;\n              case AST_DefClass:\n                decl = new AST_ClassExpression(decl);\n                break;\n              case AST_Defun:\n                decl = new AST_Function(decl);\n                break;\n              case AST_GeneratorDefun:\n                decl = new AST_GeneratorFunction(decl);\n                break;\n            }\n            return new AST_ExportDefault({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: decl,\n            });\n        },\n        ExportNamedDeclaration: function(M) {\n            if (M.declaration) return new AST_ExportDeclaration({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: from_moz(M.declaration),\n            });\n            if (M.source) {\n                var aliases = [], keys = [];\n                M.specifiers.forEach(function(prop) {\n                    aliases.push(from_moz_alias(prop.exported));\n                    keys.push(from_moz_alias(prop.local));\n                });\n                return new AST_ExportForeign({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    aliases: aliases,\n                    keys: keys,\n                    path: from_moz(M.source),\n                });\n            }\n            return new AST_ExportReferences({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                properties: M.specifiers.map(function(prop) {\n                    var sym = new AST_SymbolExport(from_moz(prop.local));\n                    sym.alias = from_moz_alias(prop.exported);\n                    return sym;\n                }),\n            });\n        },\n        ImportDeclaration: function(M) {\n            var start = my_start_token(M);\n            var end = my_end_token(M);\n            var all = null, def = null, props = null;\n            M.specifiers.forEach(function(prop) {\n                var sym = new AST_SymbolImport(from_moz(prop.local));\n                switch (prop.type) {\n                  case \"ImportDefaultSpecifier\":\n                    def = sym;\n                    def.key = new AST_String({\n                        start: start,\n                        value: \"\",\n                        end: end,\n                    });\n                    break;\n                  case \"ImportNamespaceSpecifier\":\n                    all = sym;\n                    all.key = new AST_String({\n                        start: start,\n                        value: \"*\",\n                        end: end,\n                    });\n                    break;\n                  default:\n                    sym.key = from_moz_alias(prop.imported);\n                    if (!props) props = [];\n                    props.push(sym);\n                    break;\n                }\n            });\n            return new AST_Import({\n                start: start,\n                end: end,\n                all: all,\n                default: def,\n                properties: props,\n                path: from_moz(M.source),\n            });\n        },\n        ImportExpression: function(M) {\n            var start = my_start_token(M);\n            var arg = from_moz(M.source);\n            return new AST_Call({\n                start: start,\n                end: my_end_token(M),\n                expression: new AST_SymbolRef({\n                    start: start,\n                    end: arg.start,\n                    name: \"import\",\n                }),\n                args: [ arg ],\n            });\n        },\n        VariableDeclaration: function(M) {\n            return new ({\n                const: AST_Const,\n                let: AST_Let,\n            }[M.kind] || AST_Var)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                definitions: M.declarations.map(from_moz),\n            });\n        },\n        Literal: function(M) {\n            var args = {\n                start: my_start_token(M),\n                end: my_end_token(M),\n            };\n            if (M.bigint) {\n                args.value = M.bigint.toLowerCase() + \"n\";\n                return new AST_BigInt(args);\n            }\n            var val = M.value;\n            if (val === null) return new AST_Null(args);\n            var rx = M.regex;\n            if (rx && rx.pattern) {\n                // RegExpLiteral as per ESTree AST spec\n                args.value = new RegExp(rx.pattern, rx.flags);\n                args.value.raw_source = rx.pattern;\n                return new AST_RegExp(args);\n            } else if (rx) {\n                // support legacy RegExp\n                args.value = M.regex && M.raw ? M.raw : val;\n                return new AST_RegExp(args);\n            }\n            switch (typeof val) {\n              case \"string\":\n                args.value = val;\n                return new AST_String(args);\n              case \"number\":\n                if (isNaN(val)) return new AST_NaN(args);\n                var negate, node;\n                if (isFinite(val)) {\n                    negate = 1 / val < 0;\n                    args.value = negate ? -val : val;\n                    node = new AST_Number(args);\n                } else {\n                    negate = val < 0;\n                    node = new AST_Infinity(args);\n                }\n                return negate ? new AST_UnaryPrefix({\n                    start: args.start,\n                    end: args.end,\n                    operator: \"-\",\n                    expression: node,\n                }) : node;\n              case \"boolean\":\n                return new (val ? AST_True : AST_False)(args);\n            }\n        },\n        TemplateLiteral: function(M) {\n            return new AST_Template({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expressions: M.expressions.map(from_moz),\n                strings: M.quasis.map(function(el) {\n                    return el.value.raw;\n                }),\n            });\n        },\n        TaggedTemplateExpression: function(M) {\n            var tmpl = from_moz(M.quasi);\n            tmpl.start = my_start_token(M);\n            tmpl.end = my_end_token(M);\n            tmpl.tag = from_moz(M.tag);\n            return tmpl;\n        },\n        Identifier: function(M) {\n            var p, level = FROM_MOZ_STACK.length - 1;\n            do {\n                p = FROM_MOZ_STACK[--level];\n            } while (p.type == \"ArrayPattern\"\n                || p.type == \"AssignmentPattern\" && p.left === FROM_MOZ_STACK[level + 1]\n                || p.type == \"ObjectPattern\"\n                || p.type == \"Property\" && p.value === FROM_MOZ_STACK[level + 1]\n                || p.type == \"VariableDeclarator\" && p.id === FROM_MOZ_STACK[level + 1]);\n            var ctor = AST_SymbolRef;\n            switch (p.type) {\n              case \"ArrowFunctionExpression\":\n                if (p.body !== FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolFunarg;\n                break;\n              case \"BreakStatement\":\n              case \"ContinueStatement\":\n                ctor = AST_LabelRef;\n                break;\n              case \"CatchClause\":\n                ctor = AST_SymbolCatch;\n                break;\n              case \"ClassDeclaration\":\n                if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolDefClass;\n                break;\n              case \"ClassExpression\":\n                if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolClass;\n                break;\n              case \"FunctionDeclaration\":\n                ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolDefun : AST_SymbolFunarg;\n                break;\n              case \"FunctionExpression\":\n                ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolLambda : AST_SymbolFunarg;\n                break;\n              case \"LabeledStatement\":\n                ctor = AST_Label;\n                break;\n              case \"VariableDeclaration\":\n                ctor = {\n                    const: AST_SymbolConst,\n                    let: AST_SymbolLet,\n                }[p.kind] || AST_SymbolVar;\n                break;\n            }\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: M.name,\n            });\n        },\n        Super: function(M) {\n            return new AST_Super({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: \"super\",\n            });\n        },\n        ThisExpression: function(M) {\n            return new AST_This({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: \"this\",\n            });\n        },\n        ParenthesizedExpression: function(M) {\n            var node = from_moz(M.expression);\n            if (!node.start.parens) node.start.parens = [];\n            node.start.parens.push(my_start_token(M));\n            if (!node.end.parens) node.end.parens = [];\n            node.end.parens.push(my_end_token(M));\n            return node;\n        },\n        ChainExpression: function(M) {\n            var node = from_moz(M.expression);\n            node.terminal = true;\n            return node;\n        },\n    };\n\n    MOZ_TO_ME.UpdateExpression =\n    MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n        var prefix = \"prefix\" in M ? M.prefix\n            : M.type == \"UnaryExpression\" ? true : false;\n        return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n            start      : my_start_token(M),\n            end        : my_end_token(M),\n            operator   : M.operator,\n            expression : from_moz(M.argument)\n        });\n    };\n\n    map(\"EmptyStatement\", AST_EmptyStatement);\n    map(\"ExpressionStatement\", AST_SimpleStatement, \"expression>body\");\n    map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n    map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n    map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n    map(\"BreakStatement\", AST_Break, \"label>label\");\n    map(\"ContinueStatement\", AST_Continue, \"label>label\");\n    map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n    map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n    map(\"ReturnStatement\", AST_Return, \"argument>value\");\n    map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n    map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n    map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n    map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n    map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n    map(\"DebuggerStatement\", AST_Debugger);\n    map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n    map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n\n    map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n    map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n    map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n    map(\"AssignmentPattern\", AST_DefaultValue, \"left>name, right>value\");\n    map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n    map(\"NewExpression\", AST_New, \"callee>expression, arguments@args, pure=pure\");\n    map(\"CallExpression\", AST_Call, \"callee>expression, arguments@args, optional=optional, pure=pure\");\n    map(\"SequenceExpression\", AST_Sequence, \"expressions@expressions\");\n    map(\"SpreadElement\", AST_Spread, \"argument>expression\");\n    map(\"ObjectExpression\", AST_Object, \"properties@properties\");\n    map(\"AwaitExpression\", AST_Await, \"argument>expression\");\n    map(\"YieldExpression\", AST_Yield, \"argument>expression, delegate=nested\");\n\n    def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n        return to_moz_scope(\"Program\", M);\n    });\n\n    def_to_moz(AST_LambdaDefinition, function To_Moz_FunctionDeclaration(M) {\n        var params = M.argnames.map(to_moz);\n        if (M.rest) params.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        return {\n            type: \"FunctionDeclaration\",\n            id: to_moz(M.name),\n            async: is_async(M),\n            generator: is_generator(M),\n            params: params,\n            body: to_moz_scope(\"BlockStatement\", M),\n        };\n    });\n\n    def_to_moz(AST_Lambda, function To_Moz_FunctionExpression(M) {\n        var params = M.argnames.map(to_moz);\n        if (M.rest) params.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        if (is_arrow(M)) return {\n            type: \"ArrowFunctionExpression\",\n            async: is_async(M),\n            params: params,\n            body: M.value ? to_moz(M.value) : to_moz_scope(\"BlockStatement\", M),\n        };\n        return {\n            type: \"FunctionExpression\",\n            id: to_moz(M.name),\n            async: is_async(M),\n            generator: is_generator(M),\n            params: params,\n            body: to_moz_scope(\"BlockStatement\", M),\n        };\n    });\n\n    def_to_moz(AST_DefClass, function To_Moz_ClassDeclaration(M) {\n        return {\n            type: \"ClassDeclaration\",\n            id: to_moz(M.name),\n            superClass: to_moz(M.extends),\n            body: {\n                type: \"ClassBody\",\n                body: M.properties.map(to_moz),\n            },\n        };\n    });\n\n    def_to_moz(AST_ClassExpression, function To_Moz_ClassExpression(M) {\n        return {\n            type: \"ClassExpression\",\n            id: to_moz(M.name),\n            superClass: to_moz(M.extends),\n            body: {\n                type: \"ClassBody\",\n                body: M.properties.map(to_moz),\n            },\n        };\n    });\n\n    function To_Moz_MethodDefinition(kind) {\n        return function(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : M.private ? {\n                type: \"PrivateIdentifier\",\n                name: M.key.slice(1),\n            } : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            return {\n                type: \"MethodDefinition\",\n                kind: kind,\n                computed: computed,\n                key: key,\n                static: M.static,\n                value: to_moz(M.value),\n            };\n        };\n    }\n    def_to_moz(AST_ClassGetter, To_Moz_MethodDefinition(\"get\"));\n    def_to_moz(AST_ClassSetter, To_Moz_MethodDefinition(\"set\"));\n    def_to_moz(AST_ClassMethod, To_Moz_MethodDefinition(\"method\"));\n\n    def_to_moz(AST_ClassField, function To_Moz_PropertyDefinition(M) {\n        var computed = M.key instanceof AST_Node;\n        var key = computed ? to_moz(M.key) : M.private ? {\n            type: \"PrivateIdentifier\",\n            name: M.key.slice(1),\n        } : {\n            type: \"Literal\",\n            value: M.key,\n        };\n        return {\n            type: \"PropertyDefinition\",\n            computed: computed,\n            key: key,\n            static: M.static,\n            value: to_moz(M.value),\n        };\n    });\n\n    def_to_moz(AST_ClassInit, function To_Moz_StaticBlock(M) {\n        return to_moz_scope(\"StaticBlock\", M.value);\n    });\n\n    function To_Moz_ForOfStatement(is_await) {\n        return function(M) {\n            return {\n                type: \"ForOfStatement\",\n                await: is_await,\n                left: to_moz(M.init),\n                right: to_moz(M.object),\n                body: to_moz(M.body),\n            };\n        };\n    }\n    def_to_moz(AST_ForAwaitOf, To_Moz_ForOfStatement(true));\n    def_to_moz(AST_ForOf, To_Moz_ForOfStatement(false));\n\n    def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n        return {\n            type: \"ExpressionStatement\",\n            expression: set_moz_loc(M, {\n                type: \"Literal\",\n                value: M.value,\n            }),\n        };\n    });\n\n    def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n        return {\n            type: \"SwitchCase\",\n            test: to_moz(M.expression),\n            consequent: M.body.map(to_moz),\n        };\n    });\n\n    def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n        return {\n            type: \"TryStatement\",\n            block: to_moz_block(M),\n            handler: to_moz(M.bcatch),\n            guardedHandlers: [],\n            finalizer: to_moz(M.bfinally),\n        };\n    });\n\n    def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n        return {\n            type: \"CatchClause\",\n            param: to_moz(M.argname),\n            guard: null,\n            body: to_moz_block(M),\n        };\n    });\n\n    def_to_moz(AST_ExportDeclaration, function To_Moz_ExportNamedDeclaration_declaration(M) {\n        return {\n            type: \"ExportNamedDeclaration\",\n            declaration: to_moz(M.body),\n        };\n    });\n\n    def_to_moz(AST_ExportDefault, function To_Moz_ExportDefaultDeclaration(M) {\n        return {\n            type: \"ExportDefaultDeclaration\",\n            declaration: to_moz(M.body),\n        };\n    });\n\n    def_to_moz(AST_ExportForeign, function To_Moz_ExportAllDeclaration_ExportNamedDeclaration(M) {\n        if (M.keys[0].value == \"*\") return {\n            type: \"ExportAllDeclaration\",\n            exported: M.aliases[0].value == \"*\" ? null : to_moz_alias(M.aliases[0]),\n            source: to_moz(M.path),\n        };\n        var specifiers = [];\n        for (var i = 0; i < M.aliases.length; i++) {\n            specifiers.push(set_moz_loc({\n                start: M.keys[i].start,\n                end: M.aliases[i].end,\n            }, {\n                type: \"ExportSpecifier\",\n                local: to_moz_alias(M.keys[i]),\n                exported: to_moz_alias(M.aliases[i]),\n            }));\n        }\n        return {\n            type: \"ExportNamedDeclaration\",\n            specifiers: specifiers,\n            source: to_moz(M.path),\n        };\n    });\n\n    def_to_moz(AST_ExportReferences, function To_Moz_ExportNamedDeclaration_specifiers(M) {\n        return {\n            type: \"ExportNamedDeclaration\",\n            specifiers: M.properties.map(function(prop) {\n                return set_moz_loc({\n                    start: prop.start,\n                    end: prop.alias.end,\n                }, {\n                    type: \"ExportSpecifier\",\n                    local: to_moz(prop),\n                    exported: to_moz_alias(prop.alias),\n                });\n            }),\n        };\n    });\n\n    def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n        var specifiers = M.properties ? M.properties.map(function(prop) {\n            return set_moz_loc({\n                start: prop.key.start,\n                end: prop.end,\n            }, {\n                type: \"ImportSpecifier\",\n                local: to_moz(prop),\n                imported: to_moz_alias(prop.key),\n            });\n        }) : [];\n        if (M.all) specifiers.unshift(set_moz_loc(M.all, {\n            type: \"ImportNamespaceSpecifier\",\n            local: to_moz(M.all),\n        }));\n        if (M.default) specifiers.unshift(set_moz_loc(M.default, {\n            type: \"ImportDefaultSpecifier\",\n            local: to_moz(M.default),\n        }));\n        return {\n            type: \"ImportDeclaration\",\n            specifiers: specifiers,\n            source: to_moz(M.path),\n        };\n    });\n\n    def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n        return {\n            type: \"VariableDeclaration\",\n            kind: M.TYPE.toLowerCase(),\n            declarations: M.definitions.map(to_moz),\n        };\n    });\n\n    def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n        var computed = M instanceof AST_Sub;\n        var expr = {\n            type: \"MemberExpression\",\n            object: to_moz(M.expression),\n            computed: computed,\n            optional: M.optional,\n            property: computed ? to_moz(M.property) : {\n                type: \"Identifier\",\n                name: M.property,\n            },\n        };\n        return M.terminal ? {\n            type: \"ChainExpression\",\n            expression: expr,\n        } : expr;\n    });\n\n    def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n        return {\n            type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n            operator: M.operator,\n            prefix: M instanceof AST_UnaryPrefix,\n            argument: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n        return {\n            type: M.operator == \"&&\" || M.operator == \"||\" ? \"LogicalExpression\" : \"BinaryExpression\",\n            left: to_moz(M.left),\n            operator: M.operator,\n            right: to_moz(M.right)\n        };\n    });\n\n    def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n        return {\n            type: \"ArrayExpression\",\n            elements: M.elements.map(to_moz),\n        };\n    });\n\n    def_to_moz(AST_DestructuredArray, function To_Moz_ArrayPattern(M) {\n        var elements = M.elements.map(to_moz);\n        if (M.rest) elements.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        return {\n            type: \"ArrayPattern\",\n            elements: elements,\n        };\n    });\n\n    def_to_moz(AST_DestructuredKeyVal, function To_Moz_Property(M) {\n        var computed = M.key instanceof AST_Node;\n        var key = computed ? to_moz(M.key) : {\n            type: \"Literal\",\n            value: M.key,\n        };\n        return {\n            type: \"Property\",\n            kind: \"init\",\n            computed: computed,\n            key: key,\n            value: to_moz(M.value),\n        };\n    });\n\n    def_to_moz(AST_DestructuredObject, function To_Moz_ObjectPattern(M) {\n        var props = M.properties.map(to_moz);\n        if (M.rest) props.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        return {\n            type: \"ObjectPattern\",\n            properties: props,\n        };\n    });\n\n    def_to_moz(AST_ObjectProperty, function To_Moz_Property(M) {\n        var computed = M.key instanceof AST_Node;\n        var key = computed ? to_moz(M.key) : {\n            type: \"Literal\",\n            value: M.key,\n        };\n        var kind;\n        if (M instanceof AST_ObjectKeyVal) {\n            kind = \"init\";\n        } else if (M instanceof AST_ObjectGetter) {\n            kind = \"get\";\n        } else if (M instanceof AST_ObjectSetter) {\n            kind = \"set\";\n        }\n        return {\n            type: \"Property\",\n            kind: kind,\n            computed: computed,\n            method: M instanceof AST_ObjectMethod,\n            key: key,\n            value: to_moz(M.value),\n        };\n    });\n\n    def_to_moz(AST_Symbol, function To_Moz_Identifier(M) {\n        var def = M.definition();\n        return {\n            type: \"Identifier\",\n            name: def && def.mangled_name || M.name,\n        };\n    });\n\n    def_to_moz(AST_Super, function To_Moz_Super() {\n        return { type: \"Super\" };\n    });\n\n    def_to_moz(AST_This, function To_Moz_ThisExpression() {\n        return { type: \"ThisExpression\" };\n    });\n\n    def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n        return {\n            type: \"MetaProperty\",\n            meta: {\n                type: \"Identifier\",\n                name: \"new\",\n            },\n            property: {\n                type: \"Identifier\",\n                name: \"target\",\n            },\n        };\n    });\n\n    def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n        var flags = M.value.toString().match(/\\/([gimuy]*)$/)[1];\n        var value = \"/\" + M.value.raw_source + \"/\" + flags;\n        return {\n            type: \"Literal\",\n            value: value,\n            raw: value,\n            regex: {\n                pattern: M.value.raw_source,\n                flags: flags,\n            },\n        };\n    });\n\n    def_to_moz(AST_BigInt, function To_Moz_BigInt(M) {\n        var value = M.value;\n        return {\n            type: \"Literal\",\n            bigint: value.slice(0, -1),\n            raw: value,\n        };\n    });\n\n    function To_Moz_Literal(M) {\n        var value = M.value;\n        if (typeof value === \"number\" && (value < 0 || (value === 0 && 1 / value < 0))) {\n            return {\n                type: \"UnaryExpression\",\n                operator: \"-\",\n                prefix: true,\n                argument: {\n                    type: \"Literal\",\n                    value: -value,\n                    raw: M.start.raw,\n                },\n            };\n        }\n        return {\n            type: \"Literal\",\n            value: value,\n            raw: M.start.raw,\n        };\n    }\n    def_to_moz(AST_Boolean, To_Moz_Literal);\n    def_to_moz(AST_Constant, To_Moz_Literal);\n    def_to_moz(AST_Null, To_Moz_Literal);\n\n    def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n        return {\n            type: \"Identifier\",\n            name: String(M.value),\n        };\n    });\n\n    def_to_moz(AST_Template, function To_Moz_TemplateLiteral_TaggedTemplateExpression(M) {\n        var last = M.strings.length - 1;\n        var tmpl = {\n            type: \"TemplateLiteral\",\n            expressions: M.expressions.map(to_moz),\n            quasis: M.strings.map(function(str, index) {\n                return {\n                    type: \"TemplateElement\",\n                    tail: index == last,\n                    value: { raw: str },\n                };\n            }),\n        };\n        if (!M.tag) return tmpl;\n        return {\n            type: \"TaggedTemplateExpression\",\n            tag: to_moz(M.tag),\n            quasi: tmpl,\n        };\n    });\n\n    AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n    AST_Hole.DEFMETHOD(\"to_mozilla_ast\", return_null);\n    AST_Node.DEFMETHOD(\"to_mozilla_ast\", function() {\n        throw new Error(\"Cannot convert AST_\" + this.TYPE);\n    });\n\n    /* -----[ tools ]----- */\n\n    function normalize_directives(body) {\n        for (var i = 0; i < body.length; i++) {\n            var stat = body[i];\n            if (!(stat instanceof AST_SimpleStatement)) break;\n            var node = stat.body;\n            if (!(node instanceof AST_String)) break;\n            if (stat.start.pos !== node.start.pos) break;\n            body[i] = new AST_Directive(node);\n        }\n        return body;\n    }\n\n    function raw_token(moznode) {\n        if (moznode.type == \"Literal\") {\n            return moznode.raw != null ? moznode.raw : moznode.value + \"\";\n        }\n    }\n\n    function my_start_token(moznode) {\n        var loc = moznode.loc, start = loc && loc.start;\n        var range = moznode.range;\n        return new AST_Token({\n            file    : loc && loc.source,\n            line    : start && start.line,\n            col     : start && start.column,\n            pos     : range ? range[0] : moznode.start,\n            endline : start && start.line,\n            endcol  : start && start.column,\n            endpos  : range ? range[0] : moznode.start,\n            raw     : raw_token(moznode),\n        });\n    }\n\n    function my_end_token(moznode) {\n        var loc = moznode.loc, end = loc && loc.end;\n        var range = moznode.range;\n        return new AST_Token({\n            file    : loc && loc.source,\n            line    : end && end.line,\n            col     : end && end.column,\n            pos     : range ? range[1] : moznode.end,\n            endline : end && end.line,\n            endcol  : end && end.column,\n            endpos  : range ? range[1] : moznode.end,\n            raw     : raw_token(moznode),\n        });\n    }\n\n    function read_name(M) {\n        return \"\" + M[M.type == \"Identifier\" ? \"name\" : \"value\"];\n    }\n\n    function map(moztype, mytype, propmap) {\n        var moz_to_me = [\n            \"start: my_start_token(M)\",\n            \"end: my_end_token(M)\",\n        ];\n        var me_to_moz = [\n            \"type: \" + JSON.stringify(moztype),\n        ];\n\n        if (propmap) propmap.split(/\\s*,\\s*/).forEach(function(prop) {\n            var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);\n            if (!m) throw new Error(\"Can't understand property map: \" + prop);\n            var moz = m[1], how = m[2], my = m[3];\n            switch (how) {\n              case \"@\":\n                moz_to_me.push(my + \": M.\" + moz + \".map(from_moz)\");\n                me_to_moz.push(moz + \": M.\" +  my + \".map(to_moz)\");\n                break;\n              case \">\":\n                moz_to_me.push(my + \": from_moz(M.\" + moz + \")\");\n                me_to_moz.push(moz + \": to_moz(M.\" + my + \")\");\n                break;\n              case \"=\":\n                moz_to_me.push(my + \": M.\" + moz);\n                me_to_moz.push(moz + \": M.\" + my);\n                break;\n              case \"%\":\n                moz_to_me.push(my + \": from_moz(M.\" + moz + \").body\");\n                me_to_moz.push(moz + \": to_moz_block(M)\");\n                break;\n              default:\n                throw new Error(\"Can't understand operator in propmap: \" + prop);\n            }\n        });\n\n        MOZ_TO_ME[moztype] = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", [\n            \"return function From_Moz_\" + moztype + \"(M) {\",\n            \"    return new U2.AST_\" + mytype.TYPE + \"({\",\n            moz_to_me.join(\",\\n\"),\n            \"    });\",\n            \"};\",\n        ].join(\"\\n\"))(exports, my_start_token, my_end_token, from_moz);\n        def_to_moz(mytype, new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", [\n            \"return function To_Moz_\" + moztype + \"(M) {\",\n            \"    return {\",\n            me_to_moz.join(\",\\n\"),\n            \"    };\",\n            \"};\",\n        ].join(\"\\n\"))(to_moz, to_moz_block, to_moz_scope));\n    }\n\n    var FROM_MOZ_STACK = null;\n\n    function from_moz(moz) {\n        FROM_MOZ_STACK.push(moz);\n        var node = null;\n        if (moz) {\n            if (!HOP(MOZ_TO_ME, moz.type)) throw new Error(\"Unsupported type: \" + moz.type);\n            node = MOZ_TO_ME[moz.type](moz);\n        }\n        FROM_MOZ_STACK.pop();\n        return node;\n    }\n\n    function from_moz_alias(moz) {\n        return new AST_String({\n            start: my_start_token(moz),\n            value: read_name(moz),\n            end: my_end_token(moz),\n        });\n    }\n\n    AST_Node.from_mozilla_ast = function(node) {\n        var save_stack = FROM_MOZ_STACK;\n        FROM_MOZ_STACK = [];\n        var ast = from_moz(node);\n        FROM_MOZ_STACK = save_stack;\n        ast.walk(new TreeWalker(function(node) {\n            if (node instanceof AST_LabelRef) {\n                for (var level = 0, parent; parent = this.parent(level); level++) {\n                    if (parent instanceof AST_Scope) break;\n                    if (parent instanceof AST_LabeledStatement && parent.label.name == node.name) {\n                        node.thedef = parent.label;\n                        break;\n                    }\n                }\n                if (!node.thedef) {\n                    var s = node.start;\n                    js_error(\"Undefined label \" + node.name, s.file, s.line, s.col, s.pos);\n                }\n            }\n        }));\n        return ast;\n    };\n\n    function set_moz_loc(mynode, moznode) {\n        var start = mynode.start;\n        var end = mynode.end;\n        if (start.pos != null && end.endpos != null) {\n            moznode.range = [start.pos, end.endpos];\n        }\n        if (start.line) {\n            moznode.loc = {\n                start: {line: start.line, column: start.col},\n                end: end.endline ? {line: end.endline, column: end.endcol} : null,\n            };\n            if (start.file) {\n                moznode.loc.source = start.file;\n            }\n        }\n        return moznode;\n    }\n\n    function def_to_moz(mytype, handler) {\n        mytype.DEFMETHOD(\"to_mozilla_ast\", function() {\n            return set_moz_loc(this, handler(this));\n        });\n    }\n\n    function to_moz(node) {\n        return node != null ? node.to_mozilla_ast() : null;\n    }\n\n    function to_moz_alias(alias) {\n        return is_identifier_string(alias.value) ? set_moz_loc(alias, {\n            type: \"Identifier\",\n            name: alias.value,\n        }) : to_moz(alias);\n    }\n\n    function to_moz_block(node) {\n        return {\n            type: \"BlockStatement\",\n            body: node.body.map(to_moz),\n        };\n    }\n\n    function to_moz_scope(type, node) {\n        var body = node.body.map(to_moz);\n        if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n            body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n        }\n        return {\n            type: type,\n            body: body,\n        };\n    }\n})();\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAACA,OAAA;AAAAA,OAAA;AAAAA,OAAA;AAEb,CAAC,YAAW;EACR,IAAIC,SAAS,GAAG;IACZC,OAAO,EAAE,SAAAA,CAASC,CAAC,EAAE;MACjB,OAAO,IAAIC,YAAY,CAAC;QACpBC,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpBM,IAAI,EAAEC,oBAAoB,CAACP,CAAC,CAACM,IAAI,CAACE,GAAG,CAACC,QAAQ,CAAC;MACnD,CAAC,CAAC;IACN,CAAC;IACDC,uBAAuB,EAAE,SAAAA,CAASV,CAAC,EAAE;MACjC,IAAIW,QAAQ,GAAG,EAAE;QAAEC,IAAI,GAAG,IAAI;MAC9BZ,CAAC,CAACa,MAAM,CAACC,OAAO,CAAC,UAASC,KAAK,EAAE;QAC7B,IAAIA,KAAK,CAACC,IAAI,IAAI,aAAa,EAAE;UAC7BJ,IAAI,GAAGH,QAAQ,CAACM,KAAK,CAACE,QAAQ,CAAC;QACnC,CAAC,MAAM;UACHN,QAAQ,CAACO,IAAI,CAACT,QAAQ,CAACM,KAAK,CAAC,CAAC;QAClC;MACJ,CAAC,CAAC;MACF,IAAII,EAAE,GAAG,KAAKnB,CAAC,CAACoB,KAAK,GAAGC,cAAc,GAAGC,SAAS,EAAE;QAChDpB,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpBW,QAAQ,EAAEA,QAAQ;QAClBC,IAAI,EAAEA;MACV,CAAC,CAAC;MACF,IAAIW,IAAI,GAAGd,QAAQ,CAACT,CAAC,CAACM,IAAI,CAAC;MAC3B,IAAIiB,IAAI,YAAYC,kBAAkB,EAAE;QACpCL,EAAE,CAACb,IAAI,GAAGC,oBAAoB,CAACgB,IAAI,CAACjB,IAAI,CAAC;QACzCa,EAAE,CAACM,KAAK,GAAG,IAAI;MACnB,CAAC,MAAM;QACHN,EAAE,CAACb,IAAI,GAAG,EAAE;QACZa,EAAE,CAACM,KAAK,GAAGF,IAAI;MACnB;MACA,OAAOJ,EAAE;IACb,CAAC;IACDO,mBAAmB,EAAE,SAAAA,CAAS1B,CAAC,EAAE;MAC7B,IAAI2B,IAAI;MACR,IAAI3B,CAAC,CAACoB,KAAK,EAAE;QACTO,IAAI,GAAG3B,CAAC,CAAC4B,SAAS,GAAGC,uBAAuB,GAAGC,cAAc;MACjE,CAAC,MAAM;QACHH,IAAI,GAAG3B,CAAC,CAAC4B,SAAS,GAAGG,kBAAkB,GAAGC,SAAS;MACvD;MACA,IAAIrB,QAAQ,GAAG,EAAE;QAAEC,IAAI,GAAG,IAAI;MAC9BZ,CAAC,CAACa,MAAM,CAACC,OAAO,CAAC,UAASC,KAAK,EAAE;QAC7B,IAAIA,KAAK,CAACC,IAAI,IAAI,aAAa,EAAE;UAC7BJ,IAAI,GAAGH,QAAQ,CAACM,KAAK,CAACE,QAAQ,CAAC;QACnC,CAAC,MAAM;UACHN,QAAQ,CAACO,IAAI,CAACT,QAAQ,CAACM,KAAK,CAAC,CAAC;QAClC;MACJ,CAAC,CAAC;MACF,OAAO,IAAIY,IAAI,CAAC;QACZzB,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpBiC,IAAI,EAAExB,QAAQ,CAACT,CAAC,CAACkC,EAAE,CAAC;QACpBvB,QAAQ,EAAEA,QAAQ;QAClBC,IAAI,EAAEA,IAAI;QACVN,IAAI,EAAEC,oBAAoB,CAACE,QAAQ,CAACT,CAAC,CAACM,IAAI,CAAC,CAACA,IAAI;MACpD,CAAC,CAAC;IACN,CAAC;IACD6B,kBAAkB,EAAE,SAAAA,CAASnC,CAAC,EAAE;MAC5B,IAAI2B,IAAI;MACR,IAAI3B,CAAC,CAACoB,KAAK,EAAE;QACTO,IAAI,GAAG3B,CAAC,CAAC4B,SAAS,GAAGQ,0BAA0B,GAAGC,iBAAiB;MACvE,CAAC,MAAM;QACHV,IAAI,GAAG3B,CAAC,CAAC4B,SAAS,GAAGU,qBAAqB,GAAGC,YAAY;MAC7D;MACA,IAAI5B,QAAQ,GAAG,EAAE;QAAEC,IAAI,GAAG,IAAI;MAC9BZ,CAAC,CAACa,MAAM,CAACC,OAAO,CAAC,UAASC,KAAK,EAAE;QAC7B,IAAIA,KAAK,CAACC,IAAI,IAAI,aAAa,EAAE;UAC7BJ,IAAI,GAAGH,QAAQ,CAACM,KAAK,CAACE,QAAQ,CAAC;QACnC,CAAC,MAAM;UACHN,QAAQ,CAACO,IAAI,CAACT,QAAQ,CAACM,KAAK,CAAC,CAAC;QAClC;MACJ,CAAC,CAAC;MACF,OAAO,IAAIY,IAAI,CAAC;QACZzB,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpBiC,IAAI,EAAExB,QAAQ,CAACT,CAAC,CAACkC,EAAE,CAAC;QACpBvB,QAAQ,EAAEA,QAAQ;QAClBC,IAAI,EAAEA,IAAI;QACVN,IAAI,EAAEC,oBAAoB,CAACE,QAAQ,CAACT,CAAC,CAACM,IAAI,CAAC,CAACA,IAAI;MACpD,CAAC,CAAC;IACN,CAAC;IACDkC,gBAAgB,EAAE,SAAAA,CAASxC,CAAC,EAAE;MAC1B,OAAO,IAAIyC,YAAY,CAAC;QACpBvC,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpBiC,IAAI,EAAExB,QAAQ,CAACT,CAAC,CAACkC,EAAE,CAAC;QACpBQ,OAAO,EAAEjC,QAAQ,CAACT,CAAC,CAAC2C,UAAU,CAAC;QAC/BC,UAAU,EAAE5C,CAAC,CAACM,IAAI,CAACA,IAAI,CAACE,GAAG,CAACC,QAAQ;MACxC,CAAC,CAAC;IACN,CAAC;IACDoC,eAAe,EAAE,SAAAA,CAAS7C,CAAC,EAAE;MACzB,OAAO,IAAI8C,mBAAmB,CAAC;QAC3B5C,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpBiC,IAAI,EAAExB,QAAQ,CAACT,CAAC,CAACkC,EAAE,CAAC;QACpBQ,OAAO,EAAEjC,QAAQ,CAACT,CAAC,CAAC2C,UAAU,CAAC;QAC/BC,UAAU,EAAE5C,CAAC,CAACM,IAAI,CAACA,IAAI,CAACE,GAAG,CAACC,QAAQ;MACxC,CAAC,CAAC;IACN,CAAC;IACDsC,gBAAgB,EAAE,SAAAA,CAAS/C,CAAC,EAAE;MAC1B,IAAIgD,GAAG,GAAGhD,CAAC,CAACgD,GAAG;QAAEC,QAAQ,GAAG,KAAK;MACjC,IAAIjD,CAAC,CAACkD,QAAQ,EAAE;QACZF,GAAG,GAAGvC,QAAQ,CAACuC,GAAG,CAAC;MACvB,CAAC,MAAM,IAAIA,GAAG,CAAChC,IAAI,IAAI,mBAAmB,EAAE;QACxCiC,QAAQ,GAAG,IAAI;QACfD,GAAG,GAAG,GAAG,GAAGA,GAAG,CAACf,IAAI;MACxB,CAAC,MAAM;QACHe,GAAG,GAAGG,SAAS,CAACH,GAAG,CAAC;MACxB;MACA,IAAIrB,IAAI,GAAGyB,eAAe;QAAE3B,KAAK,GAAGhB,QAAQ,CAACT,CAAC,CAACyB,KAAK,CAAC;MACrD,QAAQzB,CAAC,CAACqD,IAAI;QACZ,KAAK,KAAK;UACR1B,IAAI,GAAG2B,eAAe;UACtB7B,KAAK,GAAG,IAAI8B,YAAY,CAAC9B,KAAK,CAAC;UAC/B;QACF,KAAK,KAAK;UACRE,IAAI,GAAG6B,eAAe;UACtB/B,KAAK,GAAG,IAAI8B,YAAY,CAAC9B,KAAK,CAAC;UAC/B;MAAM;MAEV,OAAO,IAAIE,IAAI,CAAC;QACZzB,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpBgD,GAAG,EAAEA,GAAG;QACRS,OAAO,EAAER,QAAQ;QACjBS,MAAM,EAAE1D,CAAC,CAAC0D,MAAM;QAChBjC,KAAK,EAAEA;MACX,CAAC,CAAC;IACN,CAAC;IACDkC,kBAAkB,EAAE,SAAAA,CAAS3D,CAAC,EAAE;MAC5B,IAAIgD,GAAG,GAAGhD,CAAC,CAACgD,GAAG;QAAEC,QAAQ,GAAG,KAAK;MACjC,IAAIjD,CAAC,CAACkD,QAAQ,EAAE;QACZF,GAAG,GAAGvC,QAAQ,CAACuC,GAAG,CAAC;MACvB,CAAC,MAAM,IAAIA,GAAG,CAAChC,IAAI,IAAI,mBAAmB,EAAE;QACxCiC,QAAQ,GAAG,IAAI;QACfD,GAAG,GAAG,GAAG,GAAGA,GAAG,CAACf,IAAI;MACxB,CAAC,MAAM;QACHe,GAAG,GAAGG,SAAS,CAACH,GAAG,CAAC;MACxB;MACA,OAAO,IAAIY,cAAc,CAAC;QACtB1D,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpBgD,GAAG,EAAEA,GAAG;QACRS,OAAO,EAAER,QAAQ;QACjBS,MAAM,EAAE1D,CAAC,CAAC0D,MAAM;QAChBjC,KAAK,EAAEhB,QAAQ,CAACT,CAAC,CAACyB,KAAK;MAC3B,CAAC,CAAC;IACN,CAAC;IACDoC,WAAW,EAAE,SAAAA,CAAS7D,CAAC,EAAE;MACrB,IAAIE,KAAK,GAAGC,cAAc,CAACH,CAAC,CAAC;MAC7B,IAAII,GAAG,GAAGC,YAAY,CAACL,CAAC,CAAC;MACzB,OAAO,IAAI8D,aAAa,CAAC;QACrB5D,KAAK,EAAEA,KAAK;QACZE,GAAG,EAAEA,GAAG;QACRqB,KAAK,EAAE,IAAIsC,kBAAkB,CAAC;UAC1B7D,KAAK,EAAEA,KAAK;UACZE,GAAG,EAAEA,GAAG;UACRE,IAAI,EAAEC,oBAAoB,CAACP,CAAC,CAACM,IAAI,CAACE,GAAG,CAACC,QAAQ,CAAC;QACnD,CAAC;MACL,CAAC,CAAC;IACN,CAAC;IACDuD,cAAc,EAAE,SAAAA,CAAShE,CAAC,EAAE;MACxB,OAAO,KAAKA,CAAC,CAACiE,KAAK,GAAGC,cAAc,GAAGC,SAAS,EAAE;QAC9CjE,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpBoE,IAAI,EAAE3D,QAAQ,CAACT,CAAC,CAACqE,IAAI,CAAC;QACtBC,MAAM,EAAE7D,QAAQ,CAACT,CAAC,CAACuE,KAAK,CAAC;QACzBjE,IAAI,EAAEG,QAAQ,CAACT,CAAC,CAACM,IAAI;MACzB,CAAC,CAAC;IACN,CAAC;IACDkE,YAAY,EAAE,SAAAA,CAASxE,CAAC,EAAE;MACtB,IAAIyE,QAAQ,GAAGzE,CAAC,CAACyE,QAAQ,IAAI,CAACzE,CAAC,CAAC0E,OAAO,CAAC;MACxC,IAAID,QAAQ,CAACE,MAAM,GAAG,CAAC,IAAI3E,CAAC,CAAC4E,eAAe,IAAI5E,CAAC,CAAC4E,eAAe,CAACD,MAAM,EAAE;QACtE,MAAM,IAAIE,KAAK,CAAC,2CAA2C,CAAC;MAChE;MACA,OAAO,IAAIC,OAAO,CAAC;QACf5E,KAAK,EAAMC,cAAc,CAACH,CAAC,CAAC;QAC5BI,GAAG,EAAQC,YAAY,CAACL,CAAC,CAAC;QAC1BM,IAAI,EAAOG,QAAQ,CAACT,CAAC,CAAC+E,KAAK,CAAC,CAACzE,IAAI;QACjC0E,MAAM,EAAKvE,QAAQ,CAACgE,QAAQ,CAAC,CAAC,CAAC,CAAC;QAChCQ,QAAQ,EAAGjF,CAAC,CAACkF,SAAS,GAAG,IAAIC,WAAW,CAAC1E,QAAQ,CAACT,CAAC,CAACkF,SAAS,CAAC,CAAC,GAAG;MACtE,CAAC,CAAC;IACN,CAAC;IACDE,QAAQ,EAAE,SAAAA,CAASpF,CAAC,EAAE;MAClB,IAAIgD,GAAG,GAAGhD,CAAC,CAACkD,QAAQ,GAAGzC,QAAQ,CAACT,CAAC,CAACgD,GAAG,CAAC,GAAGG,SAAS,CAACnD,CAAC,CAACgD,GAAG,CAAC;MACzD,IAAIqC,IAAI,GAAG;QACPnF,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpBgD,GAAG,EAAEA,GAAG;QACRvB,KAAK,EAAEhB,QAAQ,CAACT,CAAC,CAACyB,KAAK;MAC3B,CAAC;MACD,IAAIzB,CAAC,CAACqD,IAAI,IAAI,MAAM,EAAE,OAAO,KAAKrD,CAAC,CAACsF,MAAM,GAAGC,gBAAgB,GAAGC,gBAAgB,EAAEH,IAAI,CAAC;MACvFA,IAAI,CAAC5D,KAAK,GAAG,IAAI8B,YAAY,CAAC8B,IAAI,CAAC5D,KAAK,CAAC;MACzC,IAAIzB,CAAC,CAACqD,IAAI,IAAI,KAAK,EAAE,OAAO,IAAIoC,gBAAgB,CAACJ,IAAI,CAAC;MACtD,IAAIrF,CAAC,CAACqD,IAAI,IAAI,KAAK,EAAE,OAAO,IAAIqC,gBAAgB,CAACL,IAAI,CAAC;IAC1D,CAAC;IACDM,eAAe,EAAE,SAAAA,CAAS3F,CAAC,EAAE;MACzB,OAAO,IAAI4F,SAAS,CAAC;QACjB1F,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpB6F,QAAQ,EAAE7F,CAAC,CAAC6F,QAAQ,CAACrF,GAAG,CAAC,UAASsF,IAAI,EAAE;UACpC,OAAOA,IAAI,KAAK,IAAI,GAAG,IAAIC,QAAQ,EAAE,GAAGtF,QAAQ,CAACqF,IAAI,CAAC;QAC1D,CAAC;MACL,CAAC,CAAC;IACN,CAAC;IACDE,YAAY,EAAE,SAAAA,CAAShG,CAAC,EAAE;MACtB,IAAI6F,QAAQ,GAAG,EAAE;QAAEjF,IAAI,GAAG,IAAI;MAC9BZ,CAAC,CAAC6F,QAAQ,CAAC/E,OAAO,CAAC,UAASmF,EAAE,EAAE;QAC5B,IAAIA,EAAE,KAAK,IAAI,EAAE;UACbJ,QAAQ,CAAC3E,IAAI,CAAC,IAAI6E,QAAQ,EAAE,CAAC;QACjC,CAAC,MAAM,IAAIE,EAAE,CAACjF,IAAI,IAAI,aAAa,EAAE;UACjCJ,IAAI,GAAGH,QAAQ,CAACwF,EAAE,CAAChF,QAAQ,CAAC;QAChC,CAAC,MAAM;UACH4E,QAAQ,CAAC3E,IAAI,CAACT,QAAQ,CAACwF,EAAE,CAAC,CAAC;QAC/B;MACJ,CAAC,CAAC;MACF,OAAO,IAAIC,qBAAqB,CAAC;QAC7BhG,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpB6F,QAAQ,EAAEA,QAAQ;QAClBjF,IAAI,EAAEA;MACV,CAAC,CAAC;IACN,CAAC;IACDuF,aAAa,EAAE,SAAAA,CAASnG,CAAC,EAAE;MACvB,IAAIoG,KAAK,GAAG,EAAE;QAAExF,IAAI,GAAG,IAAI;MAC3BZ,CAAC,CAAC4C,UAAU,CAAC9B,OAAO,CAAC,UAASuF,IAAI,EAAE;QAChC,IAAIA,IAAI,CAACrF,IAAI,IAAI,aAAa,EAAE;UAC5BJ,IAAI,GAAGH,QAAQ,CAAC4F,IAAI,CAACpF,QAAQ,CAAC;QAClC,CAAC,MAAM;UACHmF,KAAK,CAAClF,IAAI,CAAC,IAAIoF,sBAAsB,CAAC7F,QAAQ,CAAC4F,IAAI,CAAC,CAAC,CAAC;QAC1D;MACJ,CAAC,CAAC;MACF,OAAO,IAAIE,sBAAsB,CAAC;QAC9BrG,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpB4C,UAAU,EAAEwD,KAAK;QACjBxF,IAAI,EAAEA;MACV,CAAC,CAAC;IACN,CAAC;IACD4F,gBAAgB,EAAE,SAAAA,CAASxG,CAAC,EAAE;MAC1B,OAAO,KAAKA,CAAC,CAACkD,QAAQ,GAAGuD,OAAO,GAAGC,OAAO,EAAE;QACxCxG,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpB2G,QAAQ,EAAE3G,CAAC,CAAC2G,QAAQ;QACpBC,UAAU,EAAEnG,QAAQ,CAACT,CAAC,CAACsE,MAAM,CAAC;QAC9BuC,QAAQ,EAAE7G,CAAC,CAACkD,QAAQ,GAAGzC,QAAQ,CAACT,CAAC,CAAC6G,QAAQ,CAAC,GAAG7G,CAAC,CAAC6G,QAAQ,CAAC5E;MAC7D,CAAC,CAAC;IACN,CAAC;IACD6E,YAAY,EAAE,SAAAA,CAAS9G,CAAC,EAAE;MACtB,IAAI+G,IAAI,GAAGtG,QAAQ,CAACT,CAAC,CAACgH,IAAI,CAAC;MAC3B,IAAIX,IAAI,GAAGlD,SAAS,CAACnD,CAAC,CAAC6G,QAAQ,CAAC;MAChC,IAAIE,IAAI,CAAC9E,IAAI,IAAI,KAAK,IAAIoE,IAAI,IAAI,QAAQ,EAAE,OAAO,IAAIY,aAAa,CAAC;QACjE/G,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpBiC,IAAI,EAAE;MACV,CAAC,CAAC;MACF,OAAO,IAAIyE,OAAO,CAAC;QACfxG,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpB4G,UAAU,EAAEG,IAAI;QAChBF,QAAQ,EAAER;MACd,CAAC,CAAC;IACN,CAAC;IACDa,UAAU,EAAE,SAAAA,CAASlH,CAAC,EAAE;MACpB,OAAO,KAAKA,CAAC,CAACmH,IAAI,GAAGC,QAAQ,GAAGC,WAAW,EAAE;QACzCnH,KAAK,EAAQC,cAAc,CAACH,CAAC,CAAC;QAC9BI,GAAG,EAAUC,YAAY,CAACL,CAAC,CAAC;QAC5B4G,UAAU,EAAGnG,QAAQ,CAACT,CAAC,CAACmH,IAAI,CAAC;QAC7B7G,IAAI,EAASN,CAAC,CAACsH,UAAU,CAAC9G,GAAG,CAACC,QAAQ;MAC1C,CAAC,CAAC;IACN,CAAC;IACD8G,oBAAoB,EAAE,SAAAA,CAASvH,CAAC,EAAE;MAC9B,IAAIE,KAAK,GAAGC,cAAc,CAACH,CAAC,CAAC;MAC7B,IAAII,GAAG,GAAGC,YAAY,CAACL,CAAC,CAAC;MACzB,OAAO,IAAIwH,iBAAiB,CAAC;QACzBtH,KAAK,EAAEA,KAAK;QACZE,GAAG,EAAEA,GAAG;QACRqH,OAAO,EAAE,CAAEzH,CAAC,CAAC0H,QAAQ,GAAGC,cAAc,CAAC3H,CAAC,CAAC0H,QAAQ,CAAC,GAAG,IAAIE,UAAU,CAAC;UAChE1H,KAAK,EAAEA,KAAK;UACZuB,KAAK,EAAE,GAAG;UACVrB,GAAG,EAAEA;QACT,CAAC,CAAC,CAAE;QACJyH,IAAI,EAAE,CAAE,IAAID,UAAU,CAAC;UACnB1H,KAAK,EAAEA,KAAK;UACZuB,KAAK,EAAE,GAAG;UACVrB,GAAG,EAAEA;QACT,CAAC,CAAC,CAAE;QACJ0H,IAAI,EAAErH,QAAQ,CAACT,CAAC,CAAC+H,MAAM;MAC3B,CAAC,CAAC;IACN,CAAC;IACDC,wBAAwB,EAAE,SAAAA,CAAShI,CAAC,EAAE;MAClC,IAAIiI,IAAI,GAAGxH,QAAQ,CAACT,CAAC,CAACkI,WAAW,CAAC;MAClC,IAAI,CAACD,IAAI,CAAChG,IAAI,EAAE,QAAQgG,IAAI,CAACE,IAAI;QAC/B,KAAKrG,cAAc;UACjBmG,IAAI,GAAG,IAAI5F,iBAAiB,CAAC4F,IAAI,CAAC;UAClC;QACF,KAAKpG,uBAAuB;UAC1BoG,IAAI,GAAG,IAAI7F,0BAA0B,CAAC6F,IAAI,CAAC;UAC3C;QACF,KAAKxF,YAAY;UACfwF,IAAI,GAAG,IAAInF,mBAAmB,CAACmF,IAAI,CAAC;UACpC;QACF,KAAKjG,SAAS;UACZiG,IAAI,GAAG,IAAI1F,YAAY,CAAC0F,IAAI,CAAC;UAC7B;QACF,KAAKlG,kBAAkB;UACrBkG,IAAI,GAAG,IAAI3F,qBAAqB,CAAC2F,IAAI,CAAC;UACtC;MAAM;MAEV,OAAO,IAAIG,iBAAiB,CAAC;QACzBlI,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpBM,IAAI,EAAE2H;MACV,CAAC,CAAC;IACN,CAAC;IACDI,sBAAsB,EAAE,SAAAA,CAASrI,CAAC,EAAE;MAChC,IAAIA,CAAC,CAACkI,WAAW,EAAE,OAAO,IAAII,qBAAqB,CAAC;QAChDpI,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpBM,IAAI,EAAEG,QAAQ,CAACT,CAAC,CAACkI,WAAW;MAChC,CAAC,CAAC;MACF,IAAIlI,CAAC,CAAC+H,MAAM,EAAE;QACV,IAAIN,OAAO,GAAG,EAAE;UAAEI,IAAI,GAAG,EAAE;QAC3B7H,CAAC,CAACuI,UAAU,CAACzH,OAAO,CAAC,UAASuF,IAAI,EAAE;UAChCoB,OAAO,CAACvG,IAAI,CAACyG,cAAc,CAACtB,IAAI,CAACqB,QAAQ,CAAC,CAAC;UAC3CG,IAAI,CAAC3G,IAAI,CAACyG,cAAc,CAACtB,IAAI,CAACmC,KAAK,CAAC,CAAC;QACzC,CAAC,CAAC;QACF,OAAO,IAAIhB,iBAAiB,CAAC;UACzBtH,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;UACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;UACpByH,OAAO,EAAEA,OAAO;UAChBI,IAAI,EAAEA,IAAI;UACVC,IAAI,EAAErH,QAAQ,CAACT,CAAC,CAAC+H,MAAM;QAC3B,CAAC,CAAC;MACN;MACA,OAAO,IAAIU,oBAAoB,CAAC;QAC5BvI,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpB4C,UAAU,EAAE5C,CAAC,CAACuI,UAAU,CAAC/H,GAAG,CAAC,UAAS6F,IAAI,EAAE;UACxC,IAAIqC,GAAG,GAAG,IAAIC,gBAAgB,CAAClI,QAAQ,CAAC4F,IAAI,CAACmC,KAAK,CAAC,CAAC;UACpDE,GAAG,CAACE,KAAK,GAAGjB,cAAc,CAACtB,IAAI,CAACqB,QAAQ,CAAC;UACzC,OAAOgB,GAAG;QACd,CAAC;MACL,CAAC,CAAC;IACN,CAAC;IACDG,iBAAiB,EAAE,SAAAA,CAAS7I,CAAC,EAAE;MAC3B,IAAIE,KAAK,GAAGC,cAAc,CAACH,CAAC,CAAC;MAC7B,IAAII,GAAG,GAAGC,YAAY,CAACL,CAAC,CAAC;MACzB,IAAI8I,GAAG,GAAG,IAAI;QAAEC,GAAG,GAAG,IAAI;QAAE3C,KAAK,GAAG,IAAI;MACxCpG,CAAC,CAACuI,UAAU,CAACzH,OAAO,CAAC,UAASuF,IAAI,EAAE;QAChC,IAAIqC,GAAG,GAAG,IAAIM,gBAAgB,CAACvI,QAAQ,CAAC4F,IAAI,CAACmC,KAAK,CAAC,CAAC;QACpD,QAAQnC,IAAI,CAACrF,IAAI;UACf,KAAK,wBAAwB;YAC3B+H,GAAG,GAAGL,GAAG;YACTK,GAAG,CAAC/F,GAAG,GAAG,IAAI4E,UAAU,CAAC;cACrB1H,KAAK,EAAEA,KAAK;cACZuB,KAAK,EAAE,EAAE;cACTrB,GAAG,EAAEA;YACT,CAAC,CAAC;YACF;UACF,KAAK,0BAA0B;YAC7B0I,GAAG,GAAGJ,GAAG;YACTI,GAAG,CAAC9F,GAAG,GAAG,IAAI4E,UAAU,CAAC;cACrB1H,KAAK,EAAEA,KAAK;cACZuB,KAAK,EAAE,GAAG;cACVrB,GAAG,EAAEA;YACT,CAAC,CAAC;YACF;UACF;YACEsI,GAAG,CAAC1F,GAAG,GAAG2E,cAAc,CAACtB,IAAI,CAAC4C,QAAQ,CAAC;YACvC,IAAI,CAAC7C,KAAK,EAAEA,KAAK,GAAG,EAAE;YACtBA,KAAK,CAAClF,IAAI,CAACwH,GAAG,CAAC;YACf;QAAM;MAEd,CAAC,CAAC;MACF,OAAO,IAAIQ,UAAU,CAAC;QAClBhJ,KAAK,EAAEA,KAAK;QACZE,GAAG,EAAEA,GAAG;QACR0I,GAAG,EAAEA,GAAG;QACRK,OAAO,EAAEJ,GAAG;QACZnG,UAAU,EAAEwD,KAAK;QACjB0B,IAAI,EAAErH,QAAQ,CAACT,CAAC,CAAC+H,MAAM;MAC3B,CAAC,CAAC;IACN,CAAC;IACDqB,gBAAgB,EAAE,SAAAA,CAASpJ,CAAC,EAAE;MAC1B,IAAIE,KAAK,GAAGC,cAAc,CAACH,CAAC,CAAC;MAC7B,IAAIqJ,GAAG,GAAG5I,QAAQ,CAACT,CAAC,CAAC+H,MAAM,CAAC;MAC5B,OAAO,IAAIuB,QAAQ,CAAC;QAChBpJ,KAAK,EAAEA,KAAK;QACZE,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpB4G,UAAU,EAAE,IAAI2C,aAAa,CAAC;UAC1BrJ,KAAK,EAAEA,KAAK;UACZE,GAAG,EAAEiJ,GAAG,CAACnJ,KAAK;UACd+B,IAAI,EAAE;QACV,CAAC,CAAC;QACFoD,IAAI,EAAE,CAAEgE,GAAG;MACf,CAAC,CAAC;IACN,CAAC;IACDG,mBAAmB,EAAE,SAAAA,CAASxJ,CAAC,EAAE;MAC7B,OAAO,KAAK;QACRyJ,KAAK,EAAEC,SAAS;QAChBC,GAAG,EAAEC;MACT,CAAC,CAAC5J,CAAC,CAACqD,IAAI,CAAC,IAAIwG,OAAO,EAAE;QAClB3J,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpB8J,WAAW,EAAE9J,CAAC,CAAC+J,YAAY,CAACvJ,GAAG,CAACC,QAAQ;MAC5C,CAAC,CAAC;IACN,CAAC;IACDuJ,OAAO,EAAE,SAAAA,CAAShK,CAAC,EAAE;MACjB,IAAIqF,IAAI,GAAG;QACPnF,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC;MACvB,CAAC;MACD,IAAIA,CAAC,CAACiK,MAAM,EAAE;QACV5E,IAAI,CAAC5D,KAAK,GAAGzB,CAAC,CAACiK,MAAM,CAACC,WAAW,EAAE,GAAG,GAAG;QACzC,OAAO,IAAIC,UAAU,CAAC9E,IAAI,CAAC;MAC/B;MACA,IAAI+E,GAAG,GAAGpK,CAAC,CAACyB,KAAK;MACjB,IAAI2I,GAAG,KAAK,IAAI,EAAE,OAAO,IAAIC,QAAQ,CAAChF,IAAI,CAAC;MAC3C,IAAIiF,EAAE,GAAGtK,CAAC,CAACuK,KAAK;MAChB,IAAID,EAAE,IAAIA,EAAE,CAACE,OAAO,EAAE;QAClB;QACAnF,IAAI,CAAC5D,KAAK,GAAG,IAAIgJ,MAAM,CAACH,EAAE,CAACE,OAAO,EAAEF,EAAE,CAACI,KAAK,CAAC;QAC7CrF,IAAI,CAAC5D,KAAK,CAACkJ,UAAU,GAAGL,EAAE,CAACE,OAAO;QAClC,OAAO,IAAII,UAAU,CAACvF,IAAI,CAAC;MAC/B,CAAC,MAAM,IAAIiF,EAAE,EAAE;QACX;QACAjF,IAAI,CAAC5D,KAAK,GAAGzB,CAAC,CAACuK,KAAK,IAAIvK,CAAC,CAAC6K,GAAG,GAAG7K,CAAC,CAAC6K,GAAG,GAAGT,GAAG;QAC3C,OAAO,IAAIQ,UAAU,CAACvF,IAAI,CAAC;MAC/B;MACA,QAAQ,OAAO+E,GAAG;QAChB,KAAK,QAAQ;UACX/E,IAAI,CAAC5D,KAAK,GAAG2I,GAAG;UAChB,OAAO,IAAIxC,UAAU,CAACvC,IAAI,CAAC;QAC7B,KAAK,QAAQ;UACX,IAAIyF,KAAK,CAACV,GAAG,CAAC,EAAE,OAAO,IAAIW,OAAO,CAAC1F,IAAI,CAAC;UACxC,IAAI2F,MAAM,EAAEzJ,IAAI;UAChB,IAAI0J,QAAQ,CAACb,GAAG,CAAC,EAAE;YACfY,MAAM,GAAG,CAAC,GAAGZ,GAAG,GAAG,CAAC;YACpB/E,IAAI,CAAC5D,KAAK,GAAGuJ,MAAM,GAAG,CAACZ,GAAG,GAAGA,GAAG;YAChC7I,IAAI,GAAG,IAAI2J,UAAU,CAAC7F,IAAI,CAAC;UAC/B,CAAC,MAAM;YACH2F,MAAM,GAAGZ,GAAG,GAAG,CAAC;YAChB7I,IAAI,GAAG,IAAI4J,YAAY,CAAC9F,IAAI,CAAC;UACjC;UACA,OAAO2F,MAAM,GAAG,IAAII,eAAe,CAAC;YAChClL,KAAK,EAAEmF,IAAI,CAACnF,KAAK;YACjBE,GAAG,EAAEiF,IAAI,CAACjF,GAAG;YACbiL,QAAQ,EAAE,GAAG;YACbzE,UAAU,EAAErF;UAChB,CAAC,CAAC,GAAGA,IAAI;QACX,KAAK,SAAS;UACZ,OAAO,KAAK6I,GAAG,GAAGkB,QAAQ,GAAGC,SAAS,EAAElG,IAAI,CAAC;MAAC;IAEtD,CAAC;IACDmG,eAAe,EAAE,SAAAA,CAASxL,CAAC,EAAE;MACzB,OAAO,IAAIyL,YAAY,CAAC;QACpBvL,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpB0L,WAAW,EAAE1L,CAAC,CAAC0L,WAAW,CAAClL,GAAG,CAACC,QAAQ,CAAC;QACxCkL,OAAO,EAAE3L,CAAC,CAAC4L,MAAM,CAACpL,GAAG,CAAC,UAASyF,EAAE,EAAE;UAC/B,OAAOA,EAAE,CAACxE,KAAK,CAACoJ,GAAG;QACvB,CAAC;MACL,CAAC,CAAC;IACN,CAAC;IACDgB,wBAAwB,EAAE,SAAAA,CAAS7L,CAAC,EAAE;MAClC,IAAI8L,IAAI,GAAGrL,QAAQ,CAACT,CAAC,CAAC+L,KAAK,CAAC;MAC5BD,IAAI,CAAC5L,KAAK,GAAGC,cAAc,CAACH,CAAC,CAAC;MAC9B8L,IAAI,CAAC1L,GAAG,GAAGC,YAAY,CAACL,CAAC,CAAC;MAC1B8L,IAAI,CAACE,GAAG,GAAGvL,QAAQ,CAACT,CAAC,CAACgM,GAAG,CAAC;MAC1B,OAAOF,IAAI;IACf,CAAC;IACDG,UAAU,EAAE,SAAAA,CAASjM,CAAC,EAAE;MACpB,IAAIkM,CAAC;QAAEC,KAAK,GAAGC,cAAc,CAACzH,MAAM,GAAG,CAAC;MACxC,GAAG;QACCuH,CAAC,GAAGE,cAAc,CAAC,EAAED,KAAK,CAAC;MAC/B,CAAC,QAAQD,CAAC,CAAClL,IAAI,IAAI,cAAc,IAC1BkL,CAAC,CAAClL,IAAI,IAAI,mBAAmB,IAAIkL,CAAC,CAAC7H,IAAI,KAAK+H,cAAc,CAACD,KAAK,GAAG,CAAC,CAAC,IACrED,CAAC,CAAClL,IAAI,IAAI,eAAe,IACzBkL,CAAC,CAAClL,IAAI,IAAI,UAAU,IAAIkL,CAAC,CAACzK,KAAK,KAAK2K,cAAc,CAACD,KAAK,GAAG,CAAC,CAAC,IAC7DD,CAAC,CAAClL,IAAI,IAAI,oBAAoB,IAAIkL,CAAC,CAAChK,EAAE,KAAKkK,cAAc,CAACD,KAAK,GAAG,CAAC,CAAC;MAC3E,IAAIxK,IAAI,GAAG4H,aAAa;MACxB,QAAQ2C,CAAC,CAAClL,IAAI;QACZ,KAAK,yBAAyB;UAC5B,IAAIkL,CAAC,CAAC5L,IAAI,KAAK8L,cAAc,CAACD,KAAK,GAAG,CAAC,CAAC,EAAExK,IAAI,GAAG0K,gBAAgB;UACjE;QACF,KAAK,gBAAgB;QACrB,KAAK,mBAAmB;UACtB1K,IAAI,GAAG2K,YAAY;UACnB;QACF,KAAK,aAAa;UAChB3K,IAAI,GAAG4K,eAAe;UACtB;QACF,KAAK,kBAAkB;UACrB,IAAIL,CAAC,CAAChK,EAAE,KAAKkK,cAAc,CAACD,KAAK,GAAG,CAAC,CAAC,EAAExK,IAAI,GAAG6K,kBAAkB;UACjE;QACF,KAAK,iBAAiB;UACpB,IAAIN,CAAC,CAAChK,EAAE,KAAKkK,cAAc,CAACD,KAAK,GAAG,CAAC,CAAC,EAAExK,IAAI,GAAG8K,eAAe;UAC9D;QACF,KAAK,qBAAqB;UACxB9K,IAAI,GAAGuK,CAAC,CAAChK,EAAE,KAAKkK,cAAc,CAACD,KAAK,GAAG,CAAC,CAAC,GAAGO,eAAe,GAAGL,gBAAgB;UAC9E;QACF,KAAK,oBAAoB;UACvB1K,IAAI,GAAGuK,CAAC,CAAChK,EAAE,KAAKkK,cAAc,CAACD,KAAK,GAAG,CAAC,CAAC,GAAGQ,gBAAgB,GAAGN,gBAAgB;UAC/E;QACF,KAAK,kBAAkB;UACrB1K,IAAI,GAAGiL,SAAS;UAChB;QACF,KAAK,qBAAqB;UACxBjL,IAAI,GAAG;YACH8H,KAAK,EAAEoD,eAAe;YACtBlD,GAAG,EAAEmD;UACT,CAAC,CAACZ,CAAC,CAAC7I,IAAI,CAAC,IAAI0J,aAAa;UAC1B;MAAM;MAEV,OAAO,IAAIpL,IAAI,CAAC;QACZzB,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpBiC,IAAI,EAAEjC,CAAC,CAACiC;MACZ,CAAC,CAAC;IACN,CAAC;IACD+K,KAAK,EAAE,SAAAA,CAAShN,CAAC,EAAE;MACf,OAAO,IAAIiN,SAAS,CAAC;QACjB/M,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpBiC,IAAI,EAAE;MACV,CAAC,CAAC;IACN,CAAC;IACDiL,cAAc,EAAE,SAAAA,CAASlN,CAAC,EAAE;MACxB,OAAO,IAAImN,QAAQ,CAAC;QAChBjN,KAAK,EAAEC,cAAc,CAACH,CAAC,CAAC;QACxBI,GAAG,EAAEC,YAAY,CAACL,CAAC,CAAC;QACpBiC,IAAI,EAAE;MACV,CAAC,CAAC;IACN,CAAC;IACDmL,uBAAuB,EAAE,SAAAA,CAASpN,CAAC,EAAE;MACjC,IAAIuB,IAAI,GAAGd,QAAQ,CAACT,CAAC,CAAC4G,UAAU,CAAC;MACjC,IAAI,CAACrF,IAAI,CAACrB,KAAK,CAACmN,MAAM,EAAE9L,IAAI,CAACrB,KAAK,CAACmN,MAAM,GAAG,EAAE;MAC9C9L,IAAI,CAACrB,KAAK,CAACmN,MAAM,CAACnM,IAAI,CAACf,cAAc,CAACH,CAAC,CAAC,CAAC;MACzC,IAAI,CAACuB,IAAI,CAACnB,GAAG,CAACiN,MAAM,EAAE9L,IAAI,CAACnB,GAAG,CAACiN,MAAM,GAAG,EAAE;MAC1C9L,IAAI,CAACnB,GAAG,CAACiN,MAAM,CAACnM,IAAI,CAACb,YAAY,CAACL,CAAC,CAAC,CAAC;MACrC,OAAOuB,IAAI;IACf,CAAC;IACD+L,eAAe,EAAE,SAAAA,CAAStN,CAAC,EAAE;MACzB,IAAIuB,IAAI,GAAGd,QAAQ,CAACT,CAAC,CAAC4G,UAAU,CAAC;MACjCrF,IAAI,CAACgM,QAAQ,GAAG,IAAI;MACpB,OAAOhM,IAAI;IACf;EACJ,CAAC;EAEDzB,SAAS,CAAC0N,gBAAgB,GAC1B1N,SAAS,CAAC2N,eAAe,GAAG,SAASC,YAAYA,CAAC1N,CAAC,EAAE;IACjD,IAAI2N,MAAM,GAAG,QAAQ,IAAI3N,CAAC,GAAGA,CAAC,CAAC2N,MAAM,GAC/B3N,CAAC,CAACgB,IAAI,IAAI,iBAAiB,GAAG,IAAI,GAAG,KAAK;IAChD,OAAO,KAAK2M,MAAM,GAAGvC,eAAe,GAAGwC,gBAAgB,EAAE;MACrD1N,KAAK,EAAQC,cAAc,CAACH,CAAC,CAAC;MAC9BI,GAAG,EAAUC,YAAY,CAACL,CAAC,CAAC;MAC5BqL,QAAQ,EAAKrL,CAAC,CAACqL,QAAQ;MACvBzE,UAAU,EAAGnG,QAAQ,CAACT,CAAC,CAACiB,QAAQ;IACpC,CAAC,CAAC;EACN,CAAC;EAEDT,GAAG,CAAC,gBAAgB,EAAEqN,kBAAkB,CAAC;EACzCrN,GAAG,CAAC,qBAAqB,EAAEsN,mBAAmB,EAAE,iBAAiB,CAAC;EAClEtN,GAAG,CAAC,gBAAgB,EAAEgB,kBAAkB,EAAE,WAAW,CAAC;EACtDhB,GAAG,CAAC,aAAa,EAAEuN,MAAM,EAAE,wDAAwD,CAAC;EACpFvN,GAAG,CAAC,kBAAkB,EAAEwN,oBAAoB,EAAE,wBAAwB,CAAC;EACvExN,GAAG,CAAC,gBAAgB,EAAEyN,SAAS,EAAE,aAAa,CAAC;EAC/CzN,GAAG,CAAC,mBAAmB,EAAE0N,YAAY,EAAE,aAAa,CAAC;EACrD1N,GAAG,CAAC,eAAe,EAAE2N,QAAQ,EAAE,8BAA8B,CAAC;EAC9D3N,GAAG,CAAC,iBAAiB,EAAE4N,UAAU,EAAE,qCAAqC,CAAC;EACzE5N,GAAG,CAAC,iBAAiB,EAAE6N,UAAU,EAAE,gBAAgB,CAAC;EACpD7N,GAAG,CAAC,gBAAgB,EAAE8N,SAAS,EAAE,gBAAgB,CAAC;EAClD9N,GAAG,CAAC,gBAAgB,EAAE+N,SAAS,EAAE,2BAA2B,CAAC;EAC7D/N,GAAG,CAAC,kBAAkB,EAAEgO,MAAM,EAAE,2BAA2B,CAAC;EAC5DhO,GAAG,CAAC,cAAc,EAAEiO,OAAO,EAAE,mDAAmD,CAAC;EACjFjO,GAAG,CAAC,gBAAgB,EAAEkO,SAAS,EAAE,oCAAoC,CAAC;EACtElO,GAAG,CAAC,mBAAmB,EAAEmO,YAAY,CAAC;EACtCnO,GAAG,CAAC,oBAAoB,EAAEoO,UAAU,EAAE,qBAAqB,CAAC;EAC5DpO,GAAG,CAAC,aAAa,EAAEqO,SAAS,EAAE,0BAA0B,CAAC;EAEzDrO,GAAG,CAAC,kBAAkB,EAAEsO,UAAU,EAAE,2CAA2C,CAAC;EAChFtO,GAAG,CAAC,mBAAmB,EAAEsO,UAAU,EAAE,2CAA2C,CAAC;EACjFtO,GAAG,CAAC,sBAAsB,EAAEuO,UAAU,EAAE,2CAA2C,CAAC;EACpFvO,GAAG,CAAC,mBAAmB,EAAEwO,gBAAgB,EAAE,wBAAwB,CAAC;EACpExO,GAAG,CAAC,uBAAuB,EAAEyO,eAAe,EAAE,8DAA8D,CAAC;EAC7GzO,GAAG,CAAC,eAAe,EAAE0O,OAAO,EAAE,8CAA8C,CAAC;EAC7E1O,GAAG,CAAC,gBAAgB,EAAE8I,QAAQ,EAAE,iEAAiE,CAAC;EAClG9I,GAAG,CAAC,oBAAoB,EAAE2O,YAAY,EAAE,yBAAyB,CAAC;EAClE3O,GAAG,CAAC,eAAe,EAAE4O,UAAU,EAAE,qBAAqB,CAAC;EACvD5O,GAAG,CAAC,kBAAkB,EAAE6O,UAAU,EAAE,uBAAuB,CAAC;EAC5D7O,GAAG,CAAC,iBAAiB,EAAE8O,SAAS,EAAE,qBAAqB,CAAC;EACxD9O,GAAG,CAAC,iBAAiB,EAAE+O,SAAS,EAAE,sCAAsC,CAAC;EAEzEC,UAAU,CAACvP,YAAY,EAAE,SAASwP,cAAcA,CAACzP,CAAC,EAAE;IAChD,OAAO0P,YAAY,CAAC,SAAS,EAAE1P,CAAC,CAAC;EACrC,CAAC,CAAC;EAEFwP,UAAU,CAACG,oBAAoB,EAAE,SAASC,0BAA0BA,CAAC5P,CAAC,EAAE;IACpE,IAAIa,MAAM,GAAGb,CAAC,CAACW,QAAQ,CAACH,GAAG,CAACqP,MAAM,CAAC;IACnC,IAAI7P,CAAC,CAACY,IAAI,EAAEC,MAAM,CAACK,IAAI,CAAC;MACpBF,IAAI,EAAE,aAAa;MACnBC,QAAQ,EAAE4O,MAAM,CAAC7P,CAAC,CAACY,IAAI;IAC3B,CAAC,CAAC;IACF,OAAO;MACHI,IAAI,EAAE,qBAAqB;MAC3BkB,EAAE,EAAE2N,MAAM,CAAC7P,CAAC,CAACiC,IAAI,CAAC;MAClBb,KAAK,EAAE0O,QAAQ,CAAC9P,CAAC,CAAC;MAClB4B,SAAS,EAAEmO,YAAY,CAAC/P,CAAC,CAAC;MAC1Ba,MAAM,EAAEA,MAAM;MACdP,IAAI,EAAEoP,YAAY,CAAC,gBAAgB,EAAE1P,CAAC;IAC1C,CAAC;EACL,CAAC,CAAC;EAEFwP,UAAU,CAACQ,UAAU,EAAE,SAASC,yBAAyBA,CAACjQ,CAAC,EAAE;IACzD,IAAIa,MAAM,GAAGb,CAAC,CAACW,QAAQ,CAACH,GAAG,CAACqP,MAAM,CAAC;IACnC,IAAI7P,CAAC,CAACY,IAAI,EAAEC,MAAM,CAACK,IAAI,CAAC;MACpBF,IAAI,EAAE,aAAa;MACnBC,QAAQ,EAAE4O,MAAM,CAAC7P,CAAC,CAACY,IAAI;IAC3B,CAAC,CAAC;IACF,IAAIsP,QAAQ,CAAClQ,CAAC,CAAC,EAAE,OAAO;MACpBgB,IAAI,EAAE,yBAAyB;MAC/BI,KAAK,EAAE0O,QAAQ,CAAC9P,CAAC,CAAC;MAClBa,MAAM,EAAEA,MAAM;MACdP,IAAI,EAAEN,CAAC,CAACyB,KAAK,GAAGoO,MAAM,CAAC7P,CAAC,CAACyB,KAAK,CAAC,GAAGiO,YAAY,CAAC,gBAAgB,EAAE1P,CAAC;IACtE,CAAC;IACD,OAAO;MACHgB,IAAI,EAAE,oBAAoB;MAC1BkB,EAAE,EAAE2N,MAAM,CAAC7P,CAAC,CAACiC,IAAI,CAAC;MAClBb,KAAK,EAAE0O,QAAQ,CAAC9P,CAAC,CAAC;MAClB4B,SAAS,EAAEmO,YAAY,CAAC/P,CAAC,CAAC;MAC1Ba,MAAM,EAAEA,MAAM;MACdP,IAAI,EAAEoP,YAAY,CAAC,gBAAgB,EAAE1P,CAAC;IAC1C,CAAC;EACL,CAAC,CAAC;EAEFwP,UAAU,CAAC/M,YAAY,EAAE,SAAS0N,uBAAuBA,CAACnQ,CAAC,EAAE;IACzD,OAAO;MACHgB,IAAI,EAAE,kBAAkB;MACxBkB,EAAE,EAAE2N,MAAM,CAAC7P,CAAC,CAACiC,IAAI,CAAC;MAClBU,UAAU,EAAEkN,MAAM,CAAC7P,CAAC,CAAC0C,OAAO,CAAC;MAC7BpC,IAAI,EAAE;QACFU,IAAI,EAAE,WAAW;QACjBV,IAAI,EAAEN,CAAC,CAAC4C,UAAU,CAACpC,GAAG,CAACqP,MAAM;MACjC;IACJ,CAAC;EACL,CAAC,CAAC;EAEFL,UAAU,CAAC1M,mBAAmB,EAAE,SAASsN,sBAAsBA,CAACpQ,CAAC,EAAE;IAC/D,OAAO;MACHgB,IAAI,EAAE,iBAAiB;MACvBkB,EAAE,EAAE2N,MAAM,CAAC7P,CAAC,CAACiC,IAAI,CAAC;MAClBU,UAAU,EAAEkN,MAAM,CAAC7P,CAAC,CAAC0C,OAAO,CAAC;MAC7BpC,IAAI,EAAE;QACFU,IAAI,EAAE,WAAW;QACjBV,IAAI,EAAEN,CAAC,CAAC4C,UAAU,CAACpC,GAAG,CAACqP,MAAM;MACjC;IACJ,CAAC;EACL,CAAC,CAAC;EAEF,SAASQ,uBAAuBA,CAAChN,IAAI,EAAE;IACnC,OAAO,UAASrD,CAAC,EAAE;MACf,IAAIkD,QAAQ,GAAGlD,CAAC,CAACgD,GAAG,YAAYsN,QAAQ;MACxC,IAAItN,GAAG,GAAGE,QAAQ,GAAG2M,MAAM,CAAC7P,CAAC,CAACgD,GAAG,CAAC,GAAGhD,CAAC,CAACyD,OAAO,GAAG;QAC7CzC,IAAI,EAAE,mBAAmB;QACzBiB,IAAI,EAAEjC,CAAC,CAACgD,GAAG,CAACuN,KAAK,CAAC,CAAC;MACvB,CAAC,GAAG;QACAvP,IAAI,EAAE,SAAS;QACfS,KAAK,EAAEzB,CAAC,CAACgD;MACb,CAAC;MACD,OAAO;QACHhC,IAAI,EAAE,kBAAkB;QACxBqC,IAAI,EAAEA,IAAI;QACVH,QAAQ,EAAEA,QAAQ;QAClBF,GAAG,EAAEA,GAAG;QACRU,MAAM,EAAE1D,CAAC,CAAC0D,MAAM;QAChBjC,KAAK,EAAEoO,MAAM,CAAC7P,CAAC,CAACyB,KAAK;MACzB,CAAC;IACL,CAAC;EACL;EACA+N,UAAU,CAAClM,eAAe,EAAE+M,uBAAuB,CAAC,KAAK,CAAC,CAAC;EAC3Db,UAAU,CAAChM,eAAe,EAAE6M,uBAAuB,CAAC,KAAK,CAAC,CAAC;EAC3Db,UAAU,CAACpM,eAAe,EAAEiN,uBAAuB,CAAC,QAAQ,CAAC,CAAC;EAE9Db,UAAU,CAAC5L,cAAc,EAAE,SAAS4M,yBAAyBA,CAACxQ,CAAC,EAAE;IAC7D,IAAIkD,QAAQ,GAAGlD,CAAC,CAACgD,GAAG,YAAYsN,QAAQ;IACxC,IAAItN,GAAG,GAAGE,QAAQ,GAAG2M,MAAM,CAAC7P,CAAC,CAACgD,GAAG,CAAC,GAAGhD,CAAC,CAACyD,OAAO,GAAG;MAC7CzC,IAAI,EAAE,mBAAmB;MACzBiB,IAAI,EAAEjC,CAAC,CAACgD,GAAG,CAACuN,KAAK,CAAC,CAAC;IACvB,CAAC,GAAG;MACAvP,IAAI,EAAE,SAAS;MACfS,KAAK,EAAEzB,CAAC,CAACgD;IACb,CAAC;IACD,OAAO;MACHhC,IAAI,EAAE,oBAAoB;MAC1BkC,QAAQ,EAAEA,QAAQ;MAClBF,GAAG,EAAEA,GAAG;MACRU,MAAM,EAAE1D,CAAC,CAAC0D,MAAM;MAChBjC,KAAK,EAAEoO,MAAM,CAAC7P,CAAC,CAACyB,KAAK;IACzB,CAAC;EACL,CAAC,CAAC;EAEF+N,UAAU,CAAC1L,aAAa,EAAE,SAAS2M,kBAAkBA,CAACzQ,CAAC,EAAE;IACrD,OAAO0P,YAAY,CAAC,aAAa,EAAE1P,CAAC,CAACyB,KAAK,CAAC;EAC/C,CAAC,CAAC;EAEF,SAASiP,qBAAqBA,CAACC,QAAQ,EAAE;IACrC,OAAO,UAAS3Q,CAAC,EAAE;MACf,OAAO;QACHgB,IAAI,EAAE,gBAAgB;QACtBiD,KAAK,EAAE0M,QAAQ;QACftM,IAAI,EAAEwL,MAAM,CAAC7P,CAAC,CAACoE,IAAI,CAAC;QACpBG,KAAK,EAAEsL,MAAM,CAAC7P,CAAC,CAACsE,MAAM,CAAC;QACvBhE,IAAI,EAAEuP,MAAM,CAAC7P,CAAC,CAACM,IAAI;MACvB,CAAC;IACL,CAAC;EACL;EACAkP,UAAU,CAACtL,cAAc,EAAEwM,qBAAqB,CAAC,IAAI,CAAC,CAAC;EACvDlB,UAAU,CAACrL,SAAS,EAAEuM,qBAAqB,CAAC,KAAK,CAAC,CAAC;EAEnDlB,UAAU,CAACoB,aAAa,EAAE,SAASC,gBAAgBA,CAAC7Q,CAAC,EAAE;IACnD,OAAO;MACHgB,IAAI,EAAE,qBAAqB;MAC3B4F,UAAU,EAAEkK,WAAW,CAAC9Q,CAAC,EAAE;QACvBgB,IAAI,EAAE,SAAS;QACfS,KAAK,EAAEzB,CAAC,CAACyB;MACb,CAAC;IACL,CAAC;EACL,CAAC,CAAC;EAEF+N,UAAU,CAACuB,gBAAgB,EAAE,SAASC,iBAAiBA,CAAChR,CAAC,EAAE;IACvD,OAAO;MACHgB,IAAI,EAAE,YAAY;MAClBmG,IAAI,EAAE0I,MAAM,CAAC7P,CAAC,CAAC4G,UAAU,CAAC;MAC1BU,UAAU,EAAEtH,CAAC,CAACM,IAAI,CAACE,GAAG,CAACqP,MAAM;IACjC,CAAC;EACL,CAAC,CAAC;EAEFL,UAAU,CAAC1K,OAAO,EAAE,SAASmM,mBAAmBA,CAACjR,CAAC,EAAE;IAChD,OAAO;MACHgB,IAAI,EAAE,cAAc;MACpB+D,KAAK,EAAEmM,YAAY,CAAClR,CAAC,CAAC;MACtB0E,OAAO,EAAEmL,MAAM,CAAC7P,CAAC,CAACgF,MAAM,CAAC;MACzBJ,eAAe,EAAE,EAAE;MACnBM,SAAS,EAAE2K,MAAM,CAAC7P,CAAC,CAACiF,QAAQ;IAChC,CAAC;EACL,CAAC,CAAC;EAEFuK,UAAU,CAACX,SAAS,EAAE,SAASsC,kBAAkBA,CAACnR,CAAC,EAAE;IACjD,OAAO;MACHgB,IAAI,EAAE,aAAa;MACnBD,KAAK,EAAE8O,MAAM,CAAC7P,CAAC,CAACoR,OAAO,CAAC;MACxBC,KAAK,EAAE,IAAI;MACX/Q,IAAI,EAAE4Q,YAAY,CAAClR,CAAC;IACxB,CAAC;EACL,CAAC,CAAC;EAEFwP,UAAU,CAAClH,qBAAqB,EAAE,SAASgJ,yCAAyCA,CAACtR,CAAC,EAAE;IACpF,OAAO;MACHgB,IAAI,EAAE,wBAAwB;MAC9BkH,WAAW,EAAE2H,MAAM,CAAC7P,CAAC,CAACM,IAAI;IAC9B,CAAC;EACL,CAAC,CAAC;EAEFkP,UAAU,CAACpH,iBAAiB,EAAE,SAASmJ,+BAA+BA,CAACvR,CAAC,EAAE;IACtE,OAAO;MACHgB,IAAI,EAAE,0BAA0B;MAChCkH,WAAW,EAAE2H,MAAM,CAAC7P,CAAC,CAACM,IAAI;IAC9B,CAAC;EACL,CAAC,CAAC;EAEFkP,UAAU,CAAChI,iBAAiB,EAAE,SAASgK,kDAAkDA,CAACxR,CAAC,EAAE;IACzF,IAAIA,CAAC,CAAC6H,IAAI,CAAC,CAAC,CAAC,CAACpG,KAAK,IAAI,GAAG,EAAE,OAAO;MAC/BT,IAAI,EAAE,sBAAsB;MAC5B0G,QAAQ,EAAE1H,CAAC,CAACyH,OAAO,CAAC,CAAC,CAAC,CAAChG,KAAK,IAAI,GAAG,GAAG,IAAI,GAAGgQ,YAAY,CAACzR,CAAC,CAACyH,OAAO,CAAC,CAAC,CAAC,CAAC;MACvEM,MAAM,EAAE8H,MAAM,CAAC7P,CAAC,CAAC8H,IAAI;IACzB,CAAC;IACD,IAAIS,UAAU,GAAG,EAAE;IACnB,KAAK,IAAImJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG1R,CAAC,CAACyH,OAAO,CAAC9C,MAAM,EAAE+M,CAAC,EAAE,EAAE;MACvCnJ,UAAU,CAACrH,IAAI,CAAC4P,WAAW,CAAC;QACxB5Q,KAAK,EAAEF,CAAC,CAAC6H,IAAI,CAAC6J,CAAC,CAAC,CAACxR,KAAK;QACtBE,GAAG,EAAEJ,CAAC,CAACyH,OAAO,CAACiK,CAAC,CAAC,CAACtR;MACtB,CAAC,EAAE;QACCY,IAAI,EAAE,iBAAiB;QACvBwH,KAAK,EAAEiJ,YAAY,CAACzR,CAAC,CAAC6H,IAAI,CAAC6J,CAAC,CAAC,CAAC;QAC9BhK,QAAQ,EAAE+J,YAAY,CAACzR,CAAC,CAACyH,OAAO,CAACiK,CAAC,CAAC;MACvC,CAAC,CAAC,CAAC;IACP;IACA,OAAO;MACH1Q,IAAI,EAAE,wBAAwB;MAC9BuH,UAAU,EAAEA,UAAU;MACtBR,MAAM,EAAE8H,MAAM,CAAC7P,CAAC,CAAC8H,IAAI;IACzB,CAAC;EACL,CAAC,CAAC;EAEF0H,UAAU,CAAC/G,oBAAoB,EAAE,SAASkJ,wCAAwCA,CAAC3R,CAAC,EAAE;IAClF,OAAO;MACHgB,IAAI,EAAE,wBAAwB;MAC9BuH,UAAU,EAAEvI,CAAC,CAAC4C,UAAU,CAACpC,GAAG,CAAC,UAAS6F,IAAI,EAAE;QACxC,OAAOyK,WAAW,CAAC;UACf5Q,KAAK,EAAEmG,IAAI,CAACnG,KAAK;UACjBE,GAAG,EAAEiG,IAAI,CAACuC,KAAK,CAACxI;QACpB,CAAC,EAAE;UACCY,IAAI,EAAE,iBAAiB;UACvBwH,KAAK,EAAEqH,MAAM,CAACxJ,IAAI,CAAC;UACnBqB,QAAQ,EAAE+J,YAAY,CAACpL,IAAI,CAACuC,KAAK;QACrC,CAAC,CAAC;MACN,CAAC;IACL,CAAC;EACL,CAAC,CAAC;EAEF4G,UAAU,CAACtG,UAAU,EAAE,SAAS0I,wBAAwBA,CAAC5R,CAAC,EAAE;IACxD,IAAIuI,UAAU,GAAGvI,CAAC,CAAC4C,UAAU,GAAG5C,CAAC,CAAC4C,UAAU,CAACpC,GAAG,CAAC,UAAS6F,IAAI,EAAE;MAC5D,OAAOyK,WAAW,CAAC;QACf5Q,KAAK,EAAEmG,IAAI,CAACrD,GAAG,CAAC9C,KAAK;QACrBE,GAAG,EAAEiG,IAAI,CAACjG;MACd,CAAC,EAAE;QACCY,IAAI,EAAE,iBAAiB;QACvBwH,KAAK,EAAEqH,MAAM,CAACxJ,IAAI,CAAC;QACnB4C,QAAQ,EAAEwI,YAAY,CAACpL,IAAI,CAACrD,GAAG;MACnC,CAAC,CAAC;IACN,CAAC,CAAC,GAAG,EAAE;IACP,IAAIhD,CAAC,CAAC8I,GAAG,EAAEP,UAAU,CAACsJ,OAAO,CAACf,WAAW,CAAC9Q,CAAC,CAAC8I,GAAG,EAAE;MAC7C9H,IAAI,EAAE,0BAA0B;MAChCwH,KAAK,EAAEqH,MAAM,CAAC7P,CAAC,CAAC8I,GAAG;IACvB,CAAC,CAAC,CAAC;IACH,IAAI9I,CAAC,CAACmJ,OAAO,EAAEZ,UAAU,CAACsJ,OAAO,CAACf,WAAW,CAAC9Q,CAAC,CAACmJ,OAAO,EAAE;MACrDnI,IAAI,EAAE,wBAAwB;MAC9BwH,KAAK,EAAEqH,MAAM,CAAC7P,CAAC,CAACmJ,OAAO;IAC3B,CAAC,CAAC,CAAC;IACH,OAAO;MACHnI,IAAI,EAAE,mBAAmB;MACzBuH,UAAU,EAAEA,UAAU;MACtBR,MAAM,EAAE8H,MAAM,CAAC7P,CAAC,CAAC8H,IAAI;IACzB,CAAC;EACL,CAAC,CAAC;EAEF0H,UAAU,CAACsC,eAAe,EAAE,SAASC,0BAA0BA,CAAC/R,CAAC,EAAE;IAC/D,OAAO;MACHgB,IAAI,EAAE,qBAAqB;MAC3BqC,IAAI,EAAErD,CAAC,CAACgS,IAAI,CAAC9H,WAAW,EAAE;MAC1BH,YAAY,EAAE/J,CAAC,CAAC8J,WAAW,CAACtJ,GAAG,CAACqP,MAAM;IAC1C,CAAC;EACL,CAAC,CAAC;EAEFL,UAAU,CAACyC,cAAc,EAAE,SAASC,uBAAuBA,CAAClS,CAAC,EAAE;IAC3D,IAAIkD,QAAQ,GAAGlD,CAAC,YAAYyG,OAAO;IACnC,IAAIM,IAAI,GAAG;MACP/F,IAAI,EAAE,kBAAkB;MACxBsD,MAAM,EAAEuL,MAAM,CAAC7P,CAAC,CAAC4G,UAAU,CAAC;MAC5B1D,QAAQ,EAAEA,QAAQ;MAClByD,QAAQ,EAAE3G,CAAC,CAAC2G,QAAQ;MACpBE,QAAQ,EAAE3D,QAAQ,GAAG2M,MAAM,CAAC7P,CAAC,CAAC6G,QAAQ,CAAC,GAAG;QACtC7F,IAAI,EAAE,YAAY;QAClBiB,IAAI,EAAEjC,CAAC,CAAC6G;MACZ;IACJ,CAAC;IACD,OAAO7G,CAAC,CAACuN,QAAQ,GAAG;MAChBvM,IAAI,EAAE,iBAAiB;MACvB4F,UAAU,EAAEG;IAChB,CAAC,GAAGA,IAAI;EACZ,CAAC,CAAC;EAEFyI,UAAU,CAAC2C,SAAS,EAAE,SAASzE,YAAYA,CAAC1N,CAAC,EAAE;IAC3C,OAAO;MACHgB,IAAI,EAAEhB,CAAC,CAACqL,QAAQ,IAAI,IAAI,IAAIrL,CAAC,CAACqL,QAAQ,IAAI,IAAI,GAAG,kBAAkB,GAAG,iBAAiB;MACvFA,QAAQ,EAAErL,CAAC,CAACqL,QAAQ;MACpBsC,MAAM,EAAE3N,CAAC,YAAYoL,eAAe;MACpCnK,QAAQ,EAAE4O,MAAM,CAAC7P,CAAC,CAAC4G,UAAU;IACjC,CAAC;EACL,CAAC,CAAC;EAEF4I,UAAU,CAACV,UAAU,EAAE,SAASsD,uBAAuBA,CAACpS,CAAC,EAAE;IACvD,OAAO;MACHgB,IAAI,EAAEhB,CAAC,CAACqL,QAAQ,IAAI,IAAI,IAAIrL,CAAC,CAACqL,QAAQ,IAAI,IAAI,GAAG,mBAAmB,GAAG,kBAAkB;MACzFhH,IAAI,EAAEwL,MAAM,CAAC7P,CAAC,CAACqE,IAAI,CAAC;MACpBgH,QAAQ,EAAErL,CAAC,CAACqL,QAAQ;MACpB9G,KAAK,EAAEsL,MAAM,CAAC7P,CAAC,CAACuE,KAAK;IACzB,CAAC;EACL,CAAC,CAAC;EAEFiL,UAAU,CAAC5J,SAAS,EAAE,SAASyM,sBAAsBA,CAACrS,CAAC,EAAE;IACrD,OAAO;MACHgB,IAAI,EAAE,iBAAiB;MACvB6E,QAAQ,EAAE7F,CAAC,CAAC6F,QAAQ,CAACrF,GAAG,CAACqP,MAAM;IACnC,CAAC;EACL,CAAC,CAAC;EAEFL,UAAU,CAACtJ,qBAAqB,EAAE,SAASoM,mBAAmBA,CAACtS,CAAC,EAAE;IAC9D,IAAI6F,QAAQ,GAAG7F,CAAC,CAAC6F,QAAQ,CAACrF,GAAG,CAACqP,MAAM,CAAC;IACrC,IAAI7P,CAAC,CAACY,IAAI,EAAEiF,QAAQ,CAAC3E,IAAI,CAAC;MACtBF,IAAI,EAAE,aAAa;MACnBC,QAAQ,EAAE4O,MAAM,CAAC7P,CAAC,CAACY,IAAI;IAC3B,CAAC,CAAC;IACF,OAAO;MACHI,IAAI,EAAE,cAAc;MACpB6E,QAAQ,EAAEA;IACd,CAAC;EACL,CAAC,CAAC;EAEF2J,UAAU,CAAClJ,sBAAsB,EAAE,SAASiM,eAAeA,CAACvS,CAAC,EAAE;IAC3D,IAAIkD,QAAQ,GAAGlD,CAAC,CAACgD,GAAG,YAAYsN,QAAQ;IACxC,IAAItN,GAAG,GAAGE,QAAQ,GAAG2M,MAAM,CAAC7P,CAAC,CAACgD,GAAG,CAAC,GAAG;MACjChC,IAAI,EAAE,SAAS;MACfS,KAAK,EAAEzB,CAAC,CAACgD;IACb,CAAC;IACD,OAAO;MACHhC,IAAI,EAAE,UAAU;MAChBqC,IAAI,EAAE,MAAM;MACZH,QAAQ,EAAEA,QAAQ;MAClBF,GAAG,EAAEA,GAAG;MACRvB,KAAK,EAAEoO,MAAM,CAAC7P,CAAC,CAACyB,KAAK;IACzB,CAAC;EACL,CAAC,CAAC;EAEF+N,UAAU,CAACjJ,sBAAsB,EAAE,SAASiM,oBAAoBA,CAACxS,CAAC,EAAE;IAChE,IAAIoG,KAAK,GAAGpG,CAAC,CAAC4C,UAAU,CAACpC,GAAG,CAACqP,MAAM,CAAC;IACpC,IAAI7P,CAAC,CAACY,IAAI,EAAEwF,KAAK,CAAClF,IAAI,CAAC;MACnBF,IAAI,EAAE,aAAa;MACnBC,QAAQ,EAAE4O,MAAM,CAAC7P,CAAC,CAACY,IAAI;IAC3B,CAAC,CAAC;IACF,OAAO;MACHI,IAAI,EAAE,eAAe;MACrB4B,UAAU,EAAEwD;IAChB,CAAC;EACL,CAAC,CAAC;EAEFoJ,UAAU,CAACiD,kBAAkB,EAAE,SAASF,eAAeA,CAACvS,CAAC,EAAE;IACvD,IAAIkD,QAAQ,GAAGlD,CAAC,CAACgD,GAAG,YAAYsN,QAAQ;IACxC,IAAItN,GAAG,GAAGE,QAAQ,GAAG2M,MAAM,CAAC7P,CAAC,CAACgD,GAAG,CAAC,GAAG;MACjChC,IAAI,EAAE,SAAS;MACfS,KAAK,EAAEzB,CAAC,CAACgD;IACb,CAAC;IACD,IAAIK,IAAI;IACR,IAAIrD,CAAC,YAAYwF,gBAAgB,EAAE;MAC/BnC,IAAI,GAAG,MAAM;IACjB,CAAC,MAAM,IAAIrD,CAAC,YAAYyF,gBAAgB,EAAE;MACtCpC,IAAI,GAAG,KAAK;IAChB,CAAC,MAAM,IAAIrD,CAAC,YAAY0F,gBAAgB,EAAE;MACtCrC,IAAI,GAAG,KAAK;IAChB;IACA,OAAO;MACHrC,IAAI,EAAE,UAAU;MAChBqC,IAAI,EAAEA,IAAI;MACVH,QAAQ,EAAEA,QAAQ;MAClBoC,MAAM,EAAEtF,CAAC,YAAYuF,gBAAgB;MACrCvC,GAAG,EAAEA,GAAG;MACRvB,KAAK,EAAEoO,MAAM,CAAC7P,CAAC,CAACyB,KAAK;IACzB,CAAC;EACL,CAAC,CAAC;EAEF+N,UAAU,CAACkD,UAAU,EAAE,SAASC,iBAAiBA,CAAC3S,CAAC,EAAE;IACjD,IAAI+I,GAAG,GAAG/I,CAAC,CAAC4S,UAAU,EAAE;IACxB,OAAO;MACH5R,IAAI,EAAE,YAAY;MAClBiB,IAAI,EAAE8G,GAAG,IAAIA,GAAG,CAAC8J,YAAY,IAAI7S,CAAC,CAACiC;IACvC,CAAC;EACL,CAAC,CAAC;EAEFuN,UAAU,CAACvC,SAAS,EAAE,SAAS6F,YAAYA,CAAA,EAAG;IAC1C,OAAO;MAAE9R,IAAI,EAAE;IAAQ,CAAC;EAC5B,CAAC,CAAC;EAEFwO,UAAU,CAACrC,QAAQ,EAAE,SAAS4F,qBAAqBA,CAAA,EAAG;IAClD,OAAO;MAAE/R,IAAI,EAAE;IAAiB,CAAC;EACrC,CAAC,CAAC;EAEFwO,UAAU,CAACvI,aAAa,EAAE,SAAS+L,mBAAmBA,CAAA,EAAG;IACrD,OAAO;MACHhS,IAAI,EAAE,cAAc;MACpBgG,IAAI,EAAE;QACFhG,IAAI,EAAE,YAAY;QAClBiB,IAAI,EAAE;MACV,CAAC;MACD4E,QAAQ,EAAE;QACN7F,IAAI,EAAE,YAAY;QAClBiB,IAAI,EAAE;MACV;IACJ,CAAC;EACL,CAAC,CAAC;EAEFuN,UAAU,CAAC5E,UAAU,EAAE,SAASqI,oBAAoBA,CAACjT,CAAC,EAAE;IACpD,IAAI0K,KAAK,GAAG1K,CAAC,CAACyB,KAAK,CAACyR,QAAQ,EAAE,CAACC,KAAK,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;IACxD,IAAI1R,KAAK,GAAG,GAAG,GAAGzB,CAAC,CAACyB,KAAK,CAACkJ,UAAU,GAAG,GAAG,GAAGD,KAAK;IAClD,OAAO;MACH1J,IAAI,EAAE,SAAS;MACfS,KAAK,EAAEA,KAAK;MACZoJ,GAAG,EAAEpJ,KAAK;MACV8I,KAAK,EAAE;QACHC,OAAO,EAAExK,CAAC,CAACyB,KAAK,CAACkJ,UAAU;QAC3BD,KAAK,EAAEA;MACX;IACJ,CAAC;EACL,CAAC,CAAC;EAEF8E,UAAU,CAACrF,UAAU,EAAE,SAASiJ,aAAaA,CAACpT,CAAC,EAAE;IAC7C,IAAIyB,KAAK,GAAGzB,CAAC,CAACyB,KAAK;IACnB,OAAO;MACHT,IAAI,EAAE,SAAS;MACfiJ,MAAM,EAAExI,KAAK,CAAC8O,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MAC1B1F,GAAG,EAAEpJ;IACT,CAAC;EACL,CAAC,CAAC;EAEF,SAAS4R,cAAcA,CAACrT,CAAC,EAAE;IACvB,IAAIyB,KAAK,GAAGzB,CAAC,CAACyB,KAAK;IACnB,IAAI,OAAOA,KAAK,KAAK,QAAQ,KAAKA,KAAK,GAAG,CAAC,IAAKA,KAAK,KAAK,CAAC,IAAI,CAAC,GAAGA,KAAK,GAAG,CAAE,CAAC,EAAE;MAC5E,OAAO;QACHT,IAAI,EAAE,iBAAiB;QACvBqK,QAAQ,EAAE,GAAG;QACbsC,MAAM,EAAE,IAAI;QACZ1M,QAAQ,EAAE;UACND,IAAI,EAAE,SAAS;UACfS,KAAK,EAAE,CAACA,KAAK;UACboJ,GAAG,EAAE7K,CAAC,CAACE,KAAK,CAAC2K;QACjB;MACJ,CAAC;IACL;IACA,OAAO;MACH7J,IAAI,EAAE,SAAS;MACfS,KAAK,EAAEA,KAAK;MACZoJ,GAAG,EAAE7K,CAAC,CAACE,KAAK,CAAC2K;IACjB,CAAC;EACL;EACA2E,UAAU,CAAC8D,WAAW,EAAED,cAAc,CAAC;EACvC7D,UAAU,CAAC+D,YAAY,EAAEF,cAAc,CAAC;EACxC7D,UAAU,CAACnF,QAAQ,EAAEgJ,cAAc,CAAC;EAEpC7D,UAAU,CAACgE,QAAQ,EAAE,SAASC,WAAWA,CAACzT,CAAC,EAAE;IACzC,OAAO;MACHgB,IAAI,EAAE,YAAY;MAClBiB,IAAI,EAAEyR,MAAM,CAAC1T,CAAC,CAACyB,KAAK;IACxB,CAAC;EACL,CAAC,CAAC;EAEF+N,UAAU,CAAC/D,YAAY,EAAE,SAASkI,+CAA+CA,CAAC3T,CAAC,EAAE;IACjF,IAAI4T,IAAI,GAAG5T,CAAC,CAAC2L,OAAO,CAAChH,MAAM,GAAG,CAAC;IAC/B,IAAImH,IAAI,GAAG;MACP9K,IAAI,EAAE,iBAAiB;MACvB0K,WAAW,EAAE1L,CAAC,CAAC0L,WAAW,CAAClL,GAAG,CAACqP,MAAM,CAAC;MACtCjE,MAAM,EAAE5L,CAAC,CAAC2L,OAAO,CAACnL,GAAG,CAAC,UAASqT,GAAG,EAAEC,KAAK,EAAE;QACvC,OAAO;UACH9S,IAAI,EAAE,iBAAiB;UACvB+S,IAAI,EAAED,KAAK,IAAIF,IAAI;UACnBnS,KAAK,EAAE;YAAEoJ,GAAG,EAAEgJ;UAAI;QACtB,CAAC;MACL,CAAC;IACL,CAAC;IACD,IAAI,CAAC7T,CAAC,CAACgM,GAAG,EAAE,OAAOF,IAAI;IACvB,OAAO;MACH9K,IAAI,EAAE,0BAA0B;MAChCgL,GAAG,EAAE6D,MAAM,CAAC7P,CAAC,CAACgM,GAAG,CAAC;MAClBD,KAAK,EAAED;IACX,CAAC;EACL,CAAC,CAAC;EAEFkI,SAAS,CAACC,SAAS,CAAC,gBAAgB,EAAEzS,kBAAkB,CAAC0S,SAAS,CAACC,cAAc,CAAC;EAClFpO,QAAQ,CAACkO,SAAS,CAAC,gBAAgB,EAAEG,WAAW,CAAC;EACjD9D,QAAQ,CAAC2D,SAAS,CAAC,gBAAgB,EAAE,YAAW;IAC5C,MAAM,IAAIpP,KAAK,CAAC,qBAAqB,GAAG,IAAI,CAACmN,IAAI,CAAC;EACtD,CAAC,CAAC;;EAEF;;EAEA,SAASzR,oBAAoBA,CAACD,IAAI,EAAE;IAChC,KAAK,IAAIoR,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGpR,IAAI,CAACqE,MAAM,EAAE+M,CAAC,EAAE,EAAE;MAClC,IAAI2C,IAAI,GAAG/T,IAAI,CAACoR,CAAC,CAAC;MAClB,IAAI,EAAE2C,IAAI,YAAYvG,mBAAmB,CAAC,EAAE;MAC5C,IAAIvM,IAAI,GAAG8S,IAAI,CAAC/T,IAAI;MACpB,IAAI,EAAEiB,IAAI,YAAYqG,UAAU,CAAC,EAAE;MACnC,IAAIyM,IAAI,CAACnU,KAAK,CAACoU,GAAG,KAAK/S,IAAI,CAACrB,KAAK,CAACoU,GAAG,EAAE;MACvChU,IAAI,CAACoR,CAAC,CAAC,GAAG,IAAId,aAAa,CAACrP,IAAI,CAAC;IACrC;IACA,OAAOjB,IAAI;EACf;EAEA,SAASiU,SAASA,CAACC,OAAO,EAAE;IACxB,IAAIA,OAAO,CAACxT,IAAI,IAAI,SAAS,EAAE;MAC3B,OAAOwT,OAAO,CAAC3J,GAAG,IAAI,IAAI,GAAG2J,OAAO,CAAC3J,GAAG,GAAG2J,OAAO,CAAC/S,KAAK,GAAG,EAAE;IACjE;EACJ;EAEA,SAAStB,cAAcA,CAACqU,OAAO,EAAE;IAC7B,IAAIC,GAAG,GAAGD,OAAO,CAACC,GAAG;MAAEvU,KAAK,GAAGuU,GAAG,IAAIA,GAAG,CAACvU,KAAK;IAC/C,IAAIwU,KAAK,GAAGF,OAAO,CAACE,KAAK;IACzB,OAAO,IAAIC,SAAS,CAAC;MACjBC,IAAI,EAAMH,GAAG,IAAIA,GAAG,CAAC1M,MAAM;MAC3B8M,IAAI,EAAM3U,KAAK,IAAIA,KAAK,CAAC2U,IAAI;MAC7BC,GAAG,EAAO5U,KAAK,IAAIA,KAAK,CAAC6U,MAAM;MAC/BT,GAAG,EAAOI,KAAK,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAGF,OAAO,CAACtU,KAAK;MAC1C8U,OAAO,EAAG9U,KAAK,IAAIA,KAAK,CAAC2U,IAAI;MAC7BI,MAAM,EAAI/U,KAAK,IAAIA,KAAK,CAAC6U,MAAM;MAC/BG,MAAM,EAAIR,KAAK,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAGF,OAAO,CAACtU,KAAK;MAC1C2K,GAAG,EAAO0J,SAAS,CAACC,OAAO;IAC/B,CAAC,CAAC;EACN;EAEA,SAASnU,YAAYA,CAACmU,OAAO,EAAE;IAC3B,IAAIC,GAAG,GAAGD,OAAO,CAACC,GAAG;MAAErU,GAAG,GAAGqU,GAAG,IAAIA,GAAG,CAACrU,GAAG;IAC3C,IAAIsU,KAAK,GAAGF,OAAO,CAACE,KAAK;IACzB,OAAO,IAAIC,SAAS,CAAC;MACjBC,IAAI,EAAMH,GAAG,IAAIA,GAAG,CAAC1M,MAAM;MAC3B8M,IAAI,EAAMzU,GAAG,IAAIA,GAAG,CAACyU,IAAI;MACzBC,GAAG,EAAO1U,GAAG,IAAIA,GAAG,CAAC2U,MAAM;MAC3BT,GAAG,EAAOI,KAAK,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAGF,OAAO,CAACpU,GAAG;MACxC4U,OAAO,EAAG5U,GAAG,IAAIA,GAAG,CAACyU,IAAI;MACzBI,MAAM,EAAI7U,GAAG,IAAIA,GAAG,CAAC2U,MAAM;MAC3BG,MAAM,EAAIR,KAAK,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAGF,OAAO,CAACpU,GAAG;MACxCyK,GAAG,EAAO0J,SAAS,CAACC,OAAO;IAC/B,CAAC,CAAC;EACN;EAEA,SAASrR,SAASA,CAACnD,CAAC,EAAE;IAClB,OAAO,EAAE,GAAGA,CAAC,CAACA,CAAC,CAACgB,IAAI,IAAI,YAAY,GAAG,MAAM,GAAG,OAAO,CAAC;EAC5D;EAEA,SAASR,GAAGA,CAAC2U,OAAO,EAAEC,MAAM,EAAEC,OAAO,EAAE;IACnC,IAAIC,SAAS,GAAG,CACZ,0BAA0B,EAC1B,sBAAsB,CACzB;IACD,IAAIC,SAAS,GAAG,CACZ,QAAQ,GAAGC,IAAI,CAACC,SAAS,CAACN,OAAO,CAAC,CACrC;IAED,IAAIE,OAAO,EAAEA,OAAO,CAACK,KAAK,CAAC,SAAS,CAAC,CAAC5U,OAAO,CAAC,UAASuF,IAAI,EAAE;MACzD,IAAIsP,CAAC,GAAG,sCAAsC,CAACC,IAAI,CAACvP,IAAI,CAAC;MACzD,IAAI,CAACsP,CAAC,EAAE,MAAM,IAAI9Q,KAAK,CAAC,iCAAiC,GAAGwB,IAAI,CAAC;MACjE,IAAIwP,GAAG,GAAGF,CAAC,CAAC,CAAC,CAAC;QAAEG,GAAG,GAAGH,CAAC,CAAC,CAAC,CAAC;QAAEI,EAAE,GAAGJ,CAAC,CAAC,CAAC,CAAC;MACrC,QAAQG,GAAG;QACT,KAAK,GAAG;UACNR,SAAS,CAACpU,IAAI,CAAC6U,EAAE,GAAG,MAAM,GAAGF,GAAG,GAAG,gBAAgB,CAAC;UACpDN,SAAS,CAACrU,IAAI,CAAC2U,GAAG,GAAG,MAAM,GAAIE,EAAE,GAAG,cAAc,CAAC;UACnD;QACF,KAAK,GAAG;UACNT,SAAS,CAACpU,IAAI,CAAC6U,EAAE,GAAG,eAAe,GAAGF,GAAG,GAAG,GAAG,CAAC;UAChDN,SAAS,CAACrU,IAAI,CAAC2U,GAAG,GAAG,aAAa,GAAGE,EAAE,GAAG,GAAG,CAAC;UAC9C;QACF,KAAK,GAAG;UACNT,SAAS,CAACpU,IAAI,CAAC6U,EAAE,GAAG,MAAM,GAAGF,GAAG,CAAC;UACjCN,SAAS,CAACrU,IAAI,CAAC2U,GAAG,GAAG,MAAM,GAAGE,EAAE,CAAC;UACjC;QACF,KAAK,GAAG;UACNT,SAAS,CAACpU,IAAI,CAAC6U,EAAE,GAAG,eAAe,GAAGF,GAAG,GAAG,QAAQ,CAAC;UACrDN,SAAS,CAACrU,IAAI,CAAC2U,GAAG,GAAG,mBAAmB,CAAC;UACzC;QACF;UACE,MAAM,IAAIhR,KAAK,CAAC,wCAAwC,GAAGwB,IAAI,CAAC;MAAC;IAEzE,CAAC,CAAC;IAEFvG,SAAS,CAACqV,OAAO,CAAC,GAAG,IAAIa,QAAQ,CAAC,IAAI,EAAE,gBAAgB,EAAE,cAAc,EAAE,UAAU,EAAE,CAClF,2BAA2B,GAAGb,OAAO,GAAG,OAAO,EAC/C,wBAAwB,GAAGC,MAAM,CAACpD,IAAI,GAAG,IAAI,EAC7CsD,SAAS,CAACW,IAAI,CAAC,KAAK,CAAC,EACrB,SAAS,EACT,IAAI,CACP,CAACA,IAAI,CAAC,IAAI,CAAC,CAAC,CAACC,OAAO,EAAE/V,cAAc,EAAEE,YAAY,EAAEI,QAAQ,CAAC;IAC9D+O,UAAU,CAAC4F,MAAM,EAAE,IAAIY,QAAQ,CAAC,QAAQ,EAAE,cAAc,EAAE,cAAc,EAAE,CACtE,yBAAyB,GAAGb,OAAO,GAAG,OAAO,EAC7C,cAAc,EACdI,SAAS,CAACU,IAAI,CAAC,KAAK,CAAC,EACrB,QAAQ,EACR,IAAI,CACP,CAACA,IAAI,CAAC,IAAI,CAAC,CAAC,CAACpG,MAAM,EAAEqB,YAAY,EAAExB,YAAY,CAAC,CAAC;EACtD;EAEA,IAAItD,cAAc,GAAG,IAAI;EAEzB,SAAS3L,QAAQA,CAACoV,GAAG,EAAE;IACnBzJ,cAAc,CAAClL,IAAI,CAAC2U,GAAG,CAAC;IACxB,IAAItU,IAAI,GAAG,IAAI;IACf,IAAIsU,GAAG,EAAE;MACL,IAAI,CAACM,GAAG,CAACrW,SAAS,EAAE+V,GAAG,CAAC7U,IAAI,CAAC,EAAE,MAAM,IAAI6D,KAAK,CAAC,oBAAoB,GAAGgR,GAAG,CAAC7U,IAAI,CAAC;MAC/EO,IAAI,GAAGzB,SAAS,CAAC+V,GAAG,CAAC7U,IAAI,CAAC,CAAC6U,GAAG,CAAC;IACnC;IACAzJ,cAAc,CAACgK,GAAG,EAAE;IACpB,OAAO7U,IAAI;EACf;EAEA,SAASoG,cAAcA,CAACkO,GAAG,EAAE;IACzB,OAAO,IAAIjO,UAAU,CAAC;MAClB1H,KAAK,EAAEC,cAAc,CAAC0V,GAAG,CAAC;MAC1BpU,KAAK,EAAE0B,SAAS,CAAC0S,GAAG,CAAC;MACrBzV,GAAG,EAAEC,YAAY,CAACwV,GAAG;IACzB,CAAC,CAAC;EACN;EAEAvF,QAAQ,CAAC+F,gBAAgB,GAAG,UAAS9U,IAAI,EAAE;IACvC,IAAI+U,UAAU,GAAGlK,cAAc;IAC/BA,cAAc,GAAG,EAAE;IACnB,IAAImK,GAAG,GAAG9V,QAAQ,CAACc,IAAI,CAAC;IACxB6K,cAAc,GAAGkK,UAAU;IAC3BC,GAAG,CAACC,IAAI,CAAC,IAAIC,UAAU,CAAC,UAASlV,IAAI,EAAE;MACnC,IAAIA,IAAI,YAAY+K,YAAY,EAAE;QAC9B,KAAK,IAAIH,KAAK,GAAG,CAAC,EAAEuK,MAAM,EAAEA,MAAM,GAAG,IAAI,CAACA,MAAM,CAACvK,KAAK,CAAC,EAAEA,KAAK,EAAE,EAAE;UAC9D,IAAIuK,MAAM,YAAYC,SAAS,EAAE;UACjC,IAAID,MAAM,YAAY1I,oBAAoB,IAAI0I,MAAM,CAACE,KAAK,CAAC3U,IAAI,IAAIV,IAAI,CAACU,IAAI,EAAE;YAC1EV,IAAI,CAACsV,MAAM,GAAGH,MAAM,CAACE,KAAK;YAC1B;UACJ;QACJ;QACA,IAAI,CAACrV,IAAI,CAACsV,MAAM,EAAE;UACd,IAAIC,CAAC,GAAGvV,IAAI,CAACrB,KAAK;UAClB6W,QAAQ,CAAC,kBAAkB,GAAGxV,IAAI,CAACU,IAAI,EAAE6U,CAAC,CAAClC,IAAI,EAAEkC,CAAC,CAACjC,IAAI,EAAEiC,CAAC,CAAChC,GAAG,EAAEgC,CAAC,CAACxC,GAAG,CAAC;QAC1E;MACJ;IACJ,CAAC,CAAC,CAAC;IACH,OAAOiC,GAAG;EACd,CAAC;EAED,SAASzF,WAAWA,CAACkG,MAAM,EAAExC,OAAO,EAAE;IAClC,IAAItU,KAAK,GAAG8W,MAAM,CAAC9W,KAAK;IACxB,IAAIE,GAAG,GAAG4W,MAAM,CAAC5W,GAAG;IACpB,IAAIF,KAAK,CAACoU,GAAG,IAAI,IAAI,IAAIlU,GAAG,CAAC8U,MAAM,IAAI,IAAI,EAAE;MACzCV,OAAO,CAACE,KAAK,GAAG,CAACxU,KAAK,CAACoU,GAAG,EAAElU,GAAG,CAAC8U,MAAM,CAAC;IAC3C;IACA,IAAIhV,KAAK,CAAC2U,IAAI,EAAE;MACZL,OAAO,CAACC,GAAG,GAAG;QACVvU,KAAK,EAAE;UAAC2U,IAAI,EAAE3U,KAAK,CAAC2U,IAAI;UAAEE,MAAM,EAAE7U,KAAK,CAAC4U;QAAG,CAAC;QAC5C1U,GAAG,EAAEA,GAAG,CAAC4U,OAAO,GAAG;UAACH,IAAI,EAAEzU,GAAG,CAAC4U,OAAO;UAAED,MAAM,EAAE3U,GAAG,CAAC6U;QAAM,CAAC,GAAG;MACjE,CAAC;MACD,IAAI/U,KAAK,CAAC0U,IAAI,EAAE;QACZJ,OAAO,CAACC,GAAG,CAAC1M,MAAM,GAAG7H,KAAK,CAAC0U,IAAI;MACnC;IACJ;IACA,OAAOJ,OAAO;EAClB;EAEA,SAAShF,UAAUA,CAAC4F,MAAM,EAAE1Q,OAAO,EAAE;IACjC0Q,MAAM,CAACnB,SAAS,CAAC,gBAAgB,EAAE,YAAW;MAC1C,OAAOnD,WAAW,CAAC,IAAI,EAAEpM,OAAO,CAAC,IAAI,CAAC,CAAC;IAC3C,CAAC,CAAC;EACN;EAEA,SAASmL,MAAMA,CAACtO,IAAI,EAAE;IAClB,OAAOA,IAAI,IAAI,IAAI,GAAGA,IAAI,CAAC4S,cAAc,EAAE,GAAG,IAAI;EACtD;EAEA,SAAS1C,YAAYA,CAAC7I,KAAK,EAAE;IACzB,OAAOqO,oBAAoB,CAACrO,KAAK,CAACnH,KAAK,CAAC,GAAGqP,WAAW,CAAClI,KAAK,EAAE;MAC1D5H,IAAI,EAAE,YAAY;MAClBiB,IAAI,EAAE2G,KAAK,CAACnH;IAChB,CAAC,CAAC,GAAGoO,MAAM,CAACjH,KAAK,CAAC;EACtB;EAEA,SAASsI,YAAYA,CAAC3P,IAAI,EAAE;IACxB,OAAO;MACHP,IAAI,EAAE,gBAAgB;MACtBV,IAAI,EAAEiB,IAAI,CAACjB,IAAI,CAACE,GAAG,CAACqP,MAAM;IAC9B,CAAC;EACL;EAEA,SAASH,YAAYA,CAAC1O,IAAI,EAAEO,IAAI,EAAE;IAC9B,IAAIjB,IAAI,GAAGiB,IAAI,CAACjB,IAAI,CAACE,GAAG,CAACqP,MAAM,CAAC;IAChC,IAAItO,IAAI,CAACjB,IAAI,CAAC,CAAC,CAAC,YAAYwN,mBAAmB,IAAIvM,IAAI,CAACjB,IAAI,CAAC,CAAC,CAAC,CAACA,IAAI,YAAYsH,UAAU,EAAE;MACxFtH,IAAI,CAACuR,OAAO,CAAChC,MAAM,CAAC,IAAIhC,kBAAkB,CAACtM,IAAI,CAACjB,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC9D;IACA,OAAO;MACHU,IAAI,EAAEA,IAAI;MACVV,IAAI,EAAEA;IACV,CAAC;EACL;AACJ,CAAC,GAAG"},"metadata":{},"sourceType":"script","externalDependencies":[]}